<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Diaper School TCG Card Database</title>
    
    <!-- PWA Meta Tags -->
    <meta name="description" content="Diaper School TCG Card Database and Deckbuilder">
    <meta name="theme-color" content="#daac17">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Deckbuilder">
    <meta name="msapplication-TileColor" content="#2c2619">
    <meta name="msapplication-config" content="./browserconfig.xml">
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="./manifest.json">
    
    <!-- App Icons -->
    <link rel="icon" type="image/png" sizes="32x32" href="./favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="./favicon-16x16.png">
    <link rel="apple-touch-icon" sizes="180x180" href="./apple-touch-icon.png">
    
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@400;600;700&family=MedievalSharp&display=swap" rel="stylesheet">
    <!-- fflate from CDN for .zip booster import (pure JS, Electron-safe) -->
    <script src="https://cdn.jsdelivr.net/npm/fflate@0.8.2/umd/index.min.js"></script>
    <link rel="stylesheet" href="./styles.css?v=2.2">
</head>
<body>
    <div class="container">
        <!-- Header -->
        <h1>🎴 Diaper School TCG Database</h1>
        
        <!-- Controls Section -->
        <div class="controls-section">
            <div class="filter-grid">
                <div class="filter-group">
                    <label class="filter-label">Search Cards</label>
                    <input type="text" id="searchInput" class="filter-input" placeholder="Search by name, type, race...">
                </div>
                <div class="filter-group">
                    <label class="filter-label">Type Filter</label>
                    <select id="typeFilter" class="filter-select" title="Type Filter">
                        <option value="">All Types</option>
                        <option value="Monster Card">Monster Cards</option>
                        <option value="Student Card">Student Cards</option>
                        <option value="Spell Card">Spell Cards</option>
                        <option value="Item Card">Item Cards</option>
                        <option value="Artifact Card">Artifact Cards</option>
                        <option value="Booster Card">Booster Cards</option>
                        <option value="Patron Card">Patron Cards</option>
                        <option value="Environment Card">Environment Cards</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label class="filter-label">Tier Filter</label>
                    <select id="tierFilter" class="filter-select" title="Tier Filter">
                        <option value="">All Tiers</option>
                        <option value="Minion">Minion</option>
                        <option value="Utility">Utility</option>
                        <option value="Medium">Medium</option>
                        <option value="Boss">Boss</option>
                        <option value="Legendary">Legendary</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label class="filter-label">Energy Filter</label>
                    <select id="energyFilter" class="filter-select" title="Energy Filter">
                        <option value="">All Energy</option>
                        <option value="Universal">Universal</option>
                        <option value="Cryo">Cryo</option>
                        <option value="Pyro">Pyro</option>
                        <option value="Hydro">Hydro</option>
                        <option value="Geo">Geo</option>
                        <option value="Shadergy">Shadergy</option>
                    </select>
                </div>
            </div>
            
            <div class="action-buttons">
                <button id="exportBtn" class="btn btn-secondary">💾 Export Data</button>
                <button id="importBtn" class="btn btn-secondary">📁 Import Data</button>
                <button id="importFolderBtn" class="btn btn-secondary">📦 Import Booster Pack</button>
            </div>
        </div>
        
        <!-- Stats Display -->
        <div class="stats-display">
            <div class="stat-item">
                <div class="stat-number" id="totalCards">0</div>
                <div class="stat-label">Total Cards</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="monsterCards">0</div>
                <div class="stat-label">Monsters</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="studentCards">0</div>
                <div class="stat-label">Students</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="spellCards">0</div>
                <div class="stat-label">Spells</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="boosterCards">0</div>
                <div class="stat-label">Boosters</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="itemCards">0</div>
                <div class="stat-label">Items</div>
            </div>
        </div>
        
        <!-- Deck Builder Section -->
        <div class="deck-builder-section">
            <h2>🏗️ Deck Builder</h2>
            <div class="deck-controls">
                <div class="deck-stats">
                    <span class="deck-count">Deck: <span id="deckCount">0</span>/55</span>
                    <span class="deck-cost">Avg Cost: <span id="avgCost">0</span></span>
                    <span class="deck-types">M/S: <span id="deckMonsters">0</span> | Spells: <span id="deckSpells">0</span> | Items: <span id="deckItems">0</span></span>
                </div>
                <div class="deck-actions">
                    <button class="btn btn-secondary" id="clearDeckBtn">🗑️ Clear Deck</button>
                    <button class="btn btn-secondary" id="saveDeckBtn">💾 Save Deck</button>
                    <button class="btn btn-secondary" id="loadDeckBtn">📁 Load Deck</button>
                    <button class="btn btn-primary" id="loadStarterDeck1Btn">🎒 Academy Tempo</button>
                    <button class="btn btn-accent" id="loadDarklingDeckBtn">🌑♾ Darkling Control</button>
                    <button class="btn btn-accent" id="loadElementalDeckBtn">🔥❄️ Elemental Flux</button>
                    <button class="btn btn-success" id="playAllCardsBtn">▶️ Play All Cards to Board</button>
                    <button class="btn hidden-initial" id="exportPngBtn">🖼️ Export PNG Cards</button>
                    <button class="btn" id="toggleDeckBtn">👁️ Toggle Deck View</button>
                </div>
            </div>
            
            <div id="deckView" class="deck-view hidden-initial">
                <div class="deck-guidelines">
                    <h3>📋 Deck Building Guidelines</h3>
                    <ul>
                        <li><strong>Deck Size:</strong> Exactly 55 cards</li>
                        <li><strong>Monster/Student Cards:</strong> 20-30 recommended for balanced combat</li>
                        <li><strong>Spell Cards:</strong> 5-15 for versatility and control</li>
                        <li><strong>Item/Artifact Cards:</strong> 5-15 for utility and enhancement</li>
                        <li><strong>Booster Cards:</strong> 10-15 for energy management</li>
                        <li><strong>Energy Curve:</strong> Include low-cost cards (1-2) for early game</li>
                        <li><strong>Win Conditions:</strong> Include powerful late-game cards (5+ cost)</li>
                        <li><strong>Synergy:</strong> Build around racial or ability themes</li>
                    </ul>
                </div>
                
                <div id="deckContainer" class="deck-container">
                    <!-- Deck cards will be displayed here -->
                </div>
            </div>
        </div>
        
        <!-- Loading -->
        <div id="loadingSpinner" class="loading-spinner">
            <div class="spinner"></div>
            <p class="loading-text">Loading cards...</p>
        </div>
        
        <!-- No Results -->
    <div id="noResults" class="no-results hidden-initial">
            <h3>No cards found</h3>
            <p>Try adjusting your search criteria or add some new cards to get started.</p>
        </div>
        
        <!-- Cards Display -->
        <div id="cardsContainer" class="cards-grid">
            <!-- Cards will be rendered here -->
        </div>
    </div>

        <!-- Game Board Zone -->
        <div id="gameBoardZone" class="game-board-zone">
                <!-- Toolbar Toggle Button -->
                <button id="toolbarToggleBtn" title="Show/Hide Board Tools">Tools ▸</button>
                <div class="board-toolbar" id="boardToolbar">
                    <button id="snapToggleBtn" title="Toggle Snap to Grid">Snap</button>
                    <button id="gridToggleBtn" title="Toggle Grid Overlay">Grid</button>
                    <button id="saveBoardBtn" title="Save Board State">Save</button>
                    <button id="loadBoardBtn" title="Load Board State">Load</button>
                    <button id="exportBoardBtn" title="Export Board JSON">Export</button>
                    <button id="importBoardBtn" title="Import Board JSON">Import</button>
                    <button id="clearBoardBtn" title="Clear Board">Clear</button>
                    <button id="stackBtn" title="Stack Selected">Stack</button>
                    <button id="unstackBtn" title="Unstack Selected">Unstack</button>
                    <button id="tokenPaletteBtn" title="Add Tokens">Tokens</button>
                    <button id="createZoneBtn" title="Create Placeable Zone">Zone</button>
                    <button id="collectToDeckBtn" title="Collect All Cards to Face-Down Deck">Collect</button>
                    <button id="shuffleDeckBtn" title="Shuffle the Deck">Shuffle</button>
                    <button id="dealCardsBtn" title="Deal Cards from Deck">Deal</button>
                    <button id="autoArrangeBtn" title="Auto Arrange Board">Arrange</button>
                    <button id="toggleUIBtn" title="Hide/Show Card List UI">Toggle UI</button>
                </div>
                
                <!-- Life Counter -->
                <div class="life-counter" id="lifeCounter">
                    <button class="counter-btn counter-minus" id="counterMinus">−</button>
                    <div class="counter-display">
                        <span class="counter-value" id="counterValue">10</span>
                    </div>
                    <button class="counter-btn counter-plus" id="counterPlus">+</button>
                </div>
                
                <!-- Coin Flipper -->
                <div class="coin-container">
                    <div class="coin" id="coin" onclick="flipCoin()">🪙</div>
                    <div class="coin-result" id="coinResult">Click to flip!</div>
                </div>
                
                <div class="token-zone" id="discardZone">🪣 The Pail</div>
                <div class="board-grid-overlay" id="boardGridOverlay"></div>
                <div class="token-palette" id="tokenPalette">
                    <button class="red" title="Red" data-color="red"></button>
                    <button class="blue" title="Blue" data-color="blue"></button>
                    <button class="green" title="Green" data-color="green"></button>
                    <button class="white" title="White" data-color="white"></button>
                    <button class="black" title="Black" data-color="black"></button>
                </div>
        </div>
    
    <!-- Card Detail Modal -->
    <div id="cardModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title" id="modalCardTitle">Card Details</h2>
            </div>
            <div class="modal-body" id="modalCardContent">
                <!-- Card details will be loaded here -->
            </div>
            <div class="modal-actions">
                <button id="printCardBtn" class="btn">🖼️ Print as PNG</button>
                <button id="closeModalBtn" class="btn btn-secondary">✖️ Close</button>
            </div>
        </div>
    </div>

        <!-- Board Context Menu -->
        <div id="boardContextMenu" class="board-context-menu hidden"></div>
        
        <!-- Processing Indicator -->
        <div id="processingIndicator" class="processing-indicator">
            <div class="processing-header">
                <span class="processing-title">🔄 Processing</span>
                <button class="processing-toggle" id="processingToggle" title="Hide processing indicator">−</button>
            </div>
            <div class="processing-content" id="processingContent">
                <div class="processing-bar">
                    <div class="processing-fill" id="processingFill"></div>
                </div>
                <div class="processing-text" id="processingText">Ready</div>
            </div>
        </div>
    
    <script>
        // Import card data from external file
        const script = document.createElement('script');
        script.src = './TCG-cards.js';
        script.type = 'text/javascript';
        document.head.appendChild(script);

        // Wait for cards to load, then initialize
        script.onload = function() {
            init();
        };

        // Global state
        let cards = [];
        let filteredCards = [];
        let playerDeck = [];
        let deckVisible = false;
        let currentModalCard = null;
        let currentModalCardIndex = 0;
        // PNG graphic render cache/queue
        const graphicCardCache = new Map();
        const graphicRenderQueue = [];
        let graphicRendering = false;
        
        // Processing indicator state
        let processingTasks = new Map(); // Track multiple concurrent tasks
        let processingIndicatorVisible = localStorage.getItem('processingIndicatorVisible') !== 'false';
        let processingMinimized = localStorage.getItem('processingMinimized') === 'true';
        
        // Processing indicator functions
        function showProcessingIndicator(taskId, message, progress = 0) {
            if (!processingIndicatorVisible) return;
            
            const indicator = document.getElementById('processingIndicator');
            const text = document.getElementById('processingText');
            const fill = document.getElementById('processingFill');
            
            // Add or update task
            processingTasks.set(taskId, { message, progress });
            
            // Show the indicator
            indicator.classList.add('active');
            
            // Update display with current task
            updateProcessingDisplay();
        }
        
        function updateProcessingIndicator(taskId, message, progress) {
            if (!processingIndicatorVisible || !processingTasks.has(taskId)) return;
            
            processingTasks.set(taskId, { message, progress });
            updateProcessingDisplay();
        }
        
        function hideProcessingIndicator(taskId) {
            processingTasks.delete(taskId);
            
            if (processingTasks.size === 0) {
                const indicator = document.getElementById('processingIndicator');
                indicator.classList.remove('active');
            } else {
                updateProcessingDisplay();
            }
        }
        
        function updateProcessingDisplay() {
            if (processingTasks.size === 0) return;
            
            const text = document.getElementById('processingText');
            const fill = document.getElementById('processingFill');
            
            // Get the most recent task or highest progress
            let currentTask = { message: 'Processing...', progress: 0 };
            for (let task of processingTasks.values()) {
                if (task.progress > currentTask.progress) {
                    currentTask = task;
                }
            }
            
            text.textContent = currentTask.message;
            fill.style.width = currentTask.progress + '%';
        }
        
        function toggleProcessingIndicator() {
            processingIndicatorVisible = !processingIndicatorVisible;
            localStorage.setItem('processingIndicatorVisible', processingIndicatorVisible);
            
            const indicator = document.getElementById('processingIndicator');
            if (!processingIndicatorVisible) {
                indicator.classList.remove('active');
            } else if (processingTasks.size > 0) {
                indicator.classList.add('active');
            }
        }
        
        function toggleProcessingMinimized() {
            processingMinimized = !processingMinimized;
            localStorage.setItem('processingMinimized', processingMinimized);
            
            const indicator = document.getElementById('processingIndicator');
            const toggle = document.getElementById('processingToggle');
            
            indicator.classList.toggle('minimized', processingMinimized);
            toggle.textContent = processingMinimized ? '+' : '−';
            toggle.title = processingMinimized ? 'Show processing details' : 'Hide processing details';
        }

        function queueGraphicRender(card, cardIndex, graphicId, options = {}, directCallback){
            if (graphicCardCache.has(graphicId)) {
                const url = graphicCardCache.get(graphicId);
                if (directCallback) directCallback(url);
                const el = document.getElementById(graphicId);
                if (el && el.classList.contains('loading')) {
                    el.classList.remove('loading');
                    // Preserve existing art controls when updating from cache
                    const existingControls = el.querySelector('.art-controls');
                    const existingPlayBtn = el.querySelector('.play-btn-overlay');
                    el.innerHTML = `<img src='${url}' alt='${card.name}'/>`;
                    if (existingControls) el.appendChild(existingControls);
                    if (existingPlayBtn) el.appendChild(existingPlayBtn);
                }
                return;
            }
            graphicRenderQueue.push({card, cardIndex, graphicId, options, directCallback});
            processGraphicRenderQueue();
        }

        async function processGraphicRenderQueue(){
            if (graphicRendering) return;
            const job = graphicRenderQueue.shift();
            if (!job) return;
            graphicRendering = true;
            
            // Show processing indicator
            showProcessingIndicator('graphicRender', `Rendering ${job.card.name}...`, 0);
            
            try {
                const canvas = await renderCardToPNG(job.card, job.cardIndex, job.options);
                const dataUrl = canvas.toDataURL('image/png');
                graphicCardCache.set(job.graphicId, dataUrl);
                const el = document.getElementById(job.graphicId);
                if (el && !job.directCallback) {
                    // Only update if no direct callback is handling it
                    el.classList.remove('loading');
                    // Preserve existing controls when updating
                    const existingControls = el.querySelector('.art-controls');
                    const existingPlayBtn = el.querySelector('.play-btn-overlay');
                    const existingBoardActions = el.querySelector('.board-card-actions');
                    
                    if (!el.closest('.board-card')) {
                        el.innerHTML = `<img src='${dataUrl}' alt='${job.card.name}'/>`;
                        if (existingControls) el.appendChild(existingControls);
                        if (existingPlayBtn) el.appendChild(existingPlayBtn);
                    } else {
                        el.innerHTML = `<img src='${dataUrl}' alt='${job.card.name}'/>`;
                        if (existingBoardActions) el.appendChild(existingBoardActions);
                    }
                }
                updateProcessingIndicator('graphicRender', `Rendered ${job.card.name}`, 100);
                setTimeout(() => hideProcessingIndicator('graphicRender'), 500);
                if (job.directCallback) job.directCallback(dataUrl);
            } catch(e){
                console.error('Failed to render card PNG', e, job.card?.name);
                const el = document.getElementById(job.graphicId); if (el) el.textContent='Render failed';
                hideProcessingIndicator('graphicRender');
            } finally {
                graphicRendering = false;
                requestAnimationFrame(processGraphicRenderQueue);
            }
        }

        // DOM elements
        const cardsContainer = document.getElementById('cardsContainer');
        const searchInput = document.getElementById('searchInput');
        const typeFilter = document.getElementById('typeFilter');
        const tierFilter = document.getElementById('tierFilter');
        const energyFilter = document.getElementById('energyFilter');
        const loadingSpinner = document.getElementById('loadingSpinner');
        const noResults = document.getElementById('noResults');
        
        // Modals
        const cardModal = document.getElementById('cardModal');
        const printCardBtn = document.getElementById('printCardBtn');
        
        // Stats
        const totalCards = document.getElementById('totalCards');
        const monsterCards = document.getElementById('monsterCards');
        const studentCards = document.getElementById('studentCards');
        const spellCards = document.getElementById('spellCards');
        const boosterCards = document.getElementById('boosterCards');
        const itemCards = document.getElementById('itemCards');
        
        // Deck Builder elements
        const deckCount = document.getElementById('deckCount');
        const avgCost = document.getElementById('avgCost');
        const deckMonsters = document.getElementById('deckMonsters');
        const deckSpells = document.getElementById('deckSpells');
        const deckItems = document.getElementById('deckItems');
        const deckContainer = document.getElementById('deckContainer');
        const deckView = document.getElementById('deckView');
        const toggleDeckBtn = document.getElementById('toggleDeckBtn');
        const clearDeckBtn = document.getElementById('clearDeckBtn');
        const saveDeckBtn = document.getElementById('saveDeckBtn');
        const loadDeckBtn = document.getElementById('loadDeckBtn');
        const loadStarterDeck1Btn = document.getElementById('loadStarterDeck1Btn');
        const exportPngBtn = document.getElementById('exportPngBtn');
        
        // Utility functions
        function getEnergyClass(cost) {
            if (!cost) return 'energy-universal';
            const costLower = cost.toLowerCase();
            if (costLower.includes('universal')) return 'energy-universal';
            if (costLower.includes('cryo')) return 'energy-cryo';
            if (costLower.includes('pyro')) return 'energy-pyro';
            if (costLower.includes('hydro')) return 'energy-hydro';
            if (costLower.includes('geo')) return 'energy-geo';
            if (costLower.includes('shadergy')) return 'energy-shadergy';
            return 'energy-universal';
        }
        
        function getTierClass(tier) {
            if (!tier) return '';
            switch (tier.toLowerCase()) {
                case 'minion': return 'tier-minion';
                case 'utility': return 'tier-utility';
                case 'medium': return 'tier-medium';
                case 'boss': return 'tier-boss';
                case 'legendary': return 'tier-legendary';
                default: return '';
            }
        }
        
        function generateId() {
            return 'card_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }
        
        // Parse stat bonuses from ability descriptions
        function parseStatBonuses(description) {
            if (!description) return { atk: 0, hp: 0 };
            
            const bonuses = { atk: 0, hp: 0 };
            
            // Match +X ATK patterns
            const atkMatch = description.match(/\+(\d+)\s*(ATK|Attack)/i);
            if (atkMatch) {
                bonuses.atk = parseInt(atkMatch[1]);
            }
            
            // Match +X HP patterns  
            const hpMatch = description.match(/\+(\d+)\s*(HP|Health)/i);
            if (hpMatch) {
                bonuses.hp = parseInt(hpMatch[1]);
            }
            
            return bonuses;
        }
        
        // Art variant system - now fully automatic!
        // No more manual hard-coding needed - the system automatically detects numbered variants
        
        /* OLD HARDCODED SYSTEM - NO LONGER NEEDED
        const artVariants = {
            // This has been replaced with automatic detection
        };
        */

        // Track current art variant index for each card instance
        const currentArtIndex = {};

        // Cache for art variants to avoid repeated checks
        const artVariantsCache = new Map();
        
        // Check if an image exists by trying to load it
        function checkImageExists(imagePath) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => resolve(true);
                img.onerror = () => resolve(false);
                img.src = imagePath;
            });
        }
        
        // Preload art variants for a card (async, but caches result)
        async function preloadArtVariants(card) {
            const cacheKey = card.id;
            if (artVariantsCache.has(cacheKey)) {
                return artVariantsCache.get(cacheKey);
            }
            
            const baseImagePath = card.image_url || card.image_placeholder;
            if (!baseImagePath) {
                artVariantsCache.set(cacheKey, [baseImagePath]);
                return [baseImagePath];
            }

            // Always start with the assigned image_url as the primary art
            const primary = baseImagePath;
            const pathParts = baseImagePath.split('/');
            const filename = pathParts.pop();
            const basePath = pathParts.join('/') + '/';
            const match = filename.match(/^(.+?)(?:\s*\((\d+)\))?\.(webp|png|jpg|jpeg)$/i);
            let baseName = '', currentNumber = 0, extension = '', isStartingNumbered = false;
            if (match) {
                baseName = match[1];
                currentNumber = match[2] ? parseInt(match[2]) : 0;
                extension = match[3];
                isStartingNumbered = currentNumber > 0;
            }

            // Collect variants, but never include the assigned image_url again
            const variantSet = new Set();
            // Only check for unnumbered base IF the card's default image is NOT numbered and not already the assigned image
            if (match && !isStartingNumbered) {
                const unnumberedPath = `${basePath}${baseName}.${extension}`;
                if (unnumberedPath !== primary && await checkImageExists(unnumberedPath)) {
                    variantSet.add(unnumberedPath);
                }
            }
            // Always check for numbered variants (but skip the assigned image_url)
            const checkPromises = [];
            if (match) {
                for (let i = 1; i <= 30; i++) {
                    const variantPath = `${basePath}${baseName} (${i}).${extension}`;
                    if (variantPath !== primary) {
                        checkPromises.push(
                            checkImageExists(variantPath).then(exists => exists ? variantPath : null)
                        );
                    }
                }
            }
            const results = await Promise.all(checkPromises);
            results.forEach(variant => {
                if (variant && variant !== primary) variantSet.add(variant);
            });

            // Final variant list: assigned image_url always first, then detected variants (no duplicates)
            const validVariants = [primary, ...variantSet];
            artVariantsCache.set(cacheKey, validVariants);
            return validVariants;
        }
        
        // Get available art variants for a card - synchronous (uses cache)
        function getArtVariants(card) {
            const cacheKey = card.id;
            return artVariantsCache.get(cacheKey) || [card.image_url || card.image_placeholder];
        }

        // Cycle to next art variant
        function cycleArt(cardId, cardIndex, direction = 1) {
            const card = cards.find(c => c.id === cardId) || initialCardData.find(c => c.id === cardId);
            if (!card) return;
            
            const variants = getArtVariants(card);
            if (variants.length <= 1) return;
            
            const uniqueId = `${cardId}_${cardIndex}`;
            const currentIndex = currentArtIndex[uniqueId] || 0;
            const newIndex = (currentIndex + direction + variants.length) % variants.length;
            
            currentArtIndex[uniqueId] = newIndex;
            
            // Update the art indicator
            const cardElement = document.querySelector(`[data-card-id="${cardId}"][data-card-index="${cardIndex}"]`);
            if (cardElement) {
                const indicator = cardElement.querySelector('.art-indicator');
                if (indicator) {
                    indicator.textContent = `${newIndex + 1}/${variants.length}`;
                }
                
                // Re-render the graphic with new art - clear cache and update immediately
                const graphicId = getGraphicCacheKey(cardId, cardIndex, 'list');
                const graphicElement = document.getElementById(graphicId);
                if (graphicElement) {
                    // Clear cache for this specific variant
                    graphicCardCache.delete(graphicId);
                    
                    // Show loading state
                    graphicElement.innerHTML = 'Updating...';
                    graphicElement.classList.add('loading');
                    
                    // Queue re-render with new art index and immediate callback
                    queueGraphicRender(card, cardIndex, graphicId, {mode:'list'}, (newDataUrl) => {
                        // Update the image immediately when render is complete
                        if (graphicElement) {
                            // Rebuild the entire graphic element content with updated art controls
                            const artVariants = getArtVariants(card);
                            const updatedArtControls = artVariants.length > 1 ? `
                                <div class="art-controls">
                                    <button class="art-cycle-btn prev" onclick="event.stopPropagation(); cycleArt('${cardId}', ${cardIndex}, -1)" title="Previous Art">‹</button>
                                    <span class="art-indicator">${newIndex + 1}/${artVariants.length}</span>
                                    <button class="art-cycle-btn next" onclick="event.stopPropagation(); cycleArt('${cardId}', ${cardIndex}, 1)" title="Next Art">›</button>
                                </div>
                            ` : '';
                            
                            graphicElement.innerHTML = `
                                <img src='${newDataUrl}' alt='${card.name}'/>
                                ${updatedArtControls}
                                <div class="play-btn-overlay" onclick="event.stopPropagation(); playCardToBoard('${cardId}')">Play</div>
                            `;
                            graphicElement.classList.remove('loading');
                        }
                    });
                }
            }
        }

    // Helper to distinguish cached renders by mode (list vs board)
    function getGraphicCacheKey(cardId, cardIndex, mode='list'){ return `graphic_${mode}_${cardId}_${cardIndex}`; }

    // Card rendering functions
    function renderCard(card, cardIndex) {
            const variants = getArtVariants(card);
            const uniqueCardId = `${card.id}_${cardIndex}`; // Make each rendered card unique
            const currentIndex = currentArtIndex[uniqueCardId] || 0;
            const imageUrl = variants[currentIndex] || card.image_url || card.image_placeholder;
            
            // Parse cost string to create energy symbols using energy icons
            function renderCost(costString) {
                if (!costString || costString === 'Free') return '<div class="cost-symbols cost-single"><span class="energy-icon-wrapper"><img src="src/assets/images/expeditionandgames/TCG Images/universalergy.webp" class="energy-icon" alt="U"><span class="energy-number">0</span></span></div>';
                
                const energyMap = {
                    'Universal': { icon: 'src/assets/images/expeditionandgames/TCG Images/universalergy.webp', class: 'universal' },
                    'Hydronergy': { icon: 'src/assets/images/expeditionandgames/TCG Images/Hydrergy.webp', class: 'hydro' }, 
                    'Hydro': { icon: 'src/assets/images/expeditionandgames/TCG Images/Hydrergy.webp', class: 'hydro' }, 
                    'Pyronergy': { icon: 'src/assets/images/expeditionandgames/TCG Images/Pyrergy.webp', class: 'pyro' },
                    'Pyro': { icon: 'src/assets/images/expeditionandgames/TCG Images/Pyrergy.webp', class: 'pyro' },
                    'Cryonergy': { icon: 'src/assets/images/expeditionandgames/TCG Images/cryergy.webp', class: 'cryo' },
                    'Cryo': { icon: 'src/assets/images/expeditionandgames/TCG Images/cryergy.webp', class: 'cryo' },
                    'Geonergy': { icon: 'src/assets/images/expeditionandgames/TCG Images/geoergy.webp', class: 'geo' },
                    'Geo': { icon: 'src/assets/images/expeditionandgames/TCG Images/geoergy.webp', class: 'geo' },
                    'Shadergy': { icon: 'src/assets/images/expeditionandgames/TCG Images/shadergy.webp', class: 'shadow' },
                    'Shadow': { icon: 'src/assets/images/expeditionandgames/TCG Images/shadergy.webp', class: 'shadow' }
                };
                
                let symbols = [];
                const parts = costString.split(',');
                
                parts.forEach(part => {
                    const trimmed = part.trim();
                    const match = trimmed.match(/(\d+)\s*(.+)/);
                    if (match) {
                        const amount = parseInt(match[1]);
                        const energyType = match[2].trim();
                        const energyInfo = energyMap[energyType];
                        
                        if (energyInfo) {
                            symbols.push(`<span class="energy-icon-wrapper energy-${energyInfo.class}"><img src="${energyInfo.icon}" class="energy-icon" alt="${energyType}"><span class="energy-number">${amount}</span></span>`);
                        } else {
                            // Fallback for unknown energy types
                            symbols.push(`<span class="energy-icon-wrapper energy-universal"><img src="src/assets/images/expeditionandgames/TCG Images/universalergy.webp" class="energy-icon" alt="?"><span class="energy-number">${amount}</span></span>`);
                        }
                    }
                });
                
                // Add class based on number of symbols
                const costClass = parts.length === 1 ? 'cost-single' : parts.length === 2 ? 'cost-double' : 'cost-multiple';
                return `<div class="cost-symbols ${costClass}">${symbols.join('')}</div>`;
            }
            
            // Get type indicator
            function getTypeIndicator(card) {
                const cost = card.cost ? `${renderCost(card.cost)}` : '';
                return cost ? `<div class="card-corner-info">${cost}</div>` : '';
            }
            
            // Get subtitle text
            function getSubtitle(card) {
                if (card.type?.includes('Student')) return 'Student';
                if (card.type?.includes('Monster') && card.race) return card.race;
                if (card.type?.includes('Artifact')) return 'Artifact';
                if (card.type?.includes('Spell')) return 'Spell Card';
                if (card.type?.includes('Booster')) return 'Booster';
                if (card.type?.includes('Item')) return 'Item';
                return '';
            }
            
            // Parse stat bonuses from ability descriptions
            const bonuses = parseStatBonuses(card.ability?.description);
            
            // Show base stats if they exist, otherwise show only bonuses if they exist
            const displayAtk = (card.atk !== undefined && card.atk !== null) ? card.atk : (bonuses.atk > 0 ? bonuses.atk : null);
            const displayHp = (card.hp !== undefined && card.hp !== null) ? card.hp : (bonuses.hp > 0 ? bonuses.hp : null);
            const hasStats = displayHp !== null || displayAtk !== null;
            
            // Graphic mode: use cached print-style PNG with art cycling controls
            const artVariants = getArtVariants(card);
            const artUniqueId = `${card.id}_${cardIndex}`;
            const artCurrentIndex = currentArtIndex[artUniqueId] || 0;
            const currentVariant = artVariants[artCurrentIndex] || card.image_url;
            
            const graphicId = getGraphicCacheKey(card.id, cardIndex, 'list');
            const cached = graphicCardCache.get(graphicId);
            
            // Always create art controls if there are variants, regardless of cache state
            const artControls = artVariants.length > 1 ? `
                <div class="art-controls">
                    <button class="art-cycle-btn prev" onclick="event.stopPropagation(); cycleArt('${card.id}', ${cardIndex}, -1)" title="Previous Art">‹</button>
                    <span class="art-indicator">${artCurrentIndex + 1}/${artVariants.length}</span>
                    <button class="art-cycle-btn next" onclick="event.stopPropagation(); cycleArt('${card.id}', ${cardIndex}, 1)" title="Next Art">›</button>
                </div>
            ` : '';
            
            if (cached) {
                // Image is cached, show it immediately with controls
                return `
                    <div class="card-container" data-card-id="${card.id}" data-card-index="${cardIndex}">
                        <div class='card-graphic' data-card-id='${card.id}' data-card-index='${cardIndex}' id='${graphicId}'>
                            <img src='${cached}' alt='${card.name}'/>
                            ${artControls}
                            <div class="play-btn-overlay" onclick="event.stopPropagation(); playCardToBoard('${card.id}', ${cardIndex})">Play</div>
                        </div>
                        <button onclick="event.stopPropagation(); addToDeck('${card.id}', ${cardIndex})" class="add-to-deck-side-btn" id="addBtn_${uniqueCardId}">➕</button>
                    </div>`;
            } else {
                // Image not cached, show loading placeholder but with controls ready
                queueGraphicRender(card, cardIndex, graphicId, {mode:'list'}, (newDataUrl) => {
                    // When render completes, update the image while preserving controls
                    const el = document.getElementById(graphicId);
                    if (el) {
                        el.classList.remove('loading');
                        el.innerHTML = `
                            <img src='${newDataUrl}' alt='${card.name}'/>
                            ${artControls}
                            <div class="play-btn-overlay" onclick="event.stopPropagation(); playCardToBoard('${card.id}', ${cardIndex})">Play</div>
                        `;
                    }
                });
                
                return `
                    <div class="card-container" data-card-id="${card.id}" data-card-index="${cardIndex}">
                        <div class='card-graphic loading' data-card-id='${card.id}' data-card-index='${cardIndex}' id='${graphicId}'>
                            Rendering...
                            ${artControls}
                        </div>
                        <button onclick="event.stopPropagation(); addToDeck('${card.id}', ${cardIndex})" class="add-to-deck-side-btn" id="addBtn_${uniqueCardId}">➕</button>
                    </div>`;
            }
        }
        
        function renderCards() {
            loadingSpinner.style.display = 'none';
            
            if (filteredCards.length === 0) {
                cardsContainer.innerHTML = '';
                noResults.style.display = 'block';
                return;
            }
            
            noResults.style.display = 'none';
            
            // Remove any existing event listeners
            cardsContainer.removeEventListener('click', handleCardClick);
            
            cardsContainer.innerHTML = filteredCards.map((card, index) => renderCard(card, index)).join('');
            
            // Set up event delegation for card clicks
            cardsContainer.addEventListener('click', handleCardClick);
        }
        
        function handleCardClick(event) {
            // Skip if this is a button click
            if (event.target.closest('button') || event.target.closest('.art-cycle-btn')) {
                return;
            }
            
            // Find the closest card element (either .card or .card-graphic)
            const cardElement = event.target.closest('.card') || event.target.closest('.card-graphic') || event.target.closest('.card-container');
            if (!cardElement) return;
            
            // Get the card data
            const cardIndex = parseInt(cardElement.dataset.cardIndex) || parseInt(cardElement.querySelector('[data-card-index]')?.dataset.cardIndex);
            const cardId = cardElement.dataset.cardId || cardElement.querySelector('[data-card-id]')?.dataset.cardId;
            
            let card = null;
            if (cardIndex !== undefined && cardIndex >= 0) {
                card = filteredCards[cardIndex];
            } else if (cardId) {
                card = cards.find(c => c.id === cardId);
                const foundIndex = filteredCards.findIndex(c => c.id === cardId);
                if (foundIndex >= 0) {
                    card = filteredCards[foundIndex];
                }
            }
            
            if (card) {
                showCardDetails(card, cardIndex || 0);
            }
        }
        
        function updateStats() {
            totalCards.textContent = cards.length;
            monsterCards.textContent = cards.filter(c => c.type === 'Monster Card').length;
            studentCards.textContent = cards.filter(c => c.type === 'Student Card').length;
            spellCards.textContent = cards.filter(c => c.type === 'Spell Card').length;
            boosterCards.textContent = cards.filter(c => c.type === 'Booster Card').length;
            itemCards.textContent = cards.filter(c => c.type === 'Item Card' || c.type === 'Artifact Card' || c.type === 'Patron Card').length;
        }
        
        // Deck Builder Functions
        function addToDeck(cardId, cardIndex = 0) {
            if (playerDeck.length >= 55) {
                showAppAlert('Deck is full! Maximum 55 cards allowed.');
                return;
            }
            
            const card = cards.find(c => c.id === cardId);
            if (card) {
                // Store the selected art variant with the deck card
                const variants = getArtVariants(card);
                const uniqueId = `${cardId}_${cardIndex}`;
                const artIndex = currentArtIndex[uniqueId] || 0;
                const selectedVariant = variants[artIndex] || card.image_url;
                
                const deckCard = {
                    ...card, 
                    deckId: Date.now() + Math.random(),
                    selectedArtVariant: selectedVariant,
                    artVariantIndex: artIndex
                };
                
                playerDeck.push(deckCard);
                updateDeckStats();
                updateDeckDisplay();
                updateAddButtons();
            }
        }
        
        function removeFromDeck(deckId) {
            playerDeck = playerDeck.filter(card => card.deckId !== deckId);
            updateDeckStats();
            updateDeckDisplay();
            updateAddButtons();
        }
        
        function removeFromDeckById(cardId) {
            // Find and remove one instance of the card with this ID
            const index = playerDeck.findIndex(card => card.id === cardId);
            if (index !== -1) {
                playerDeck.splice(index, 1);
                updateDeckStats();
                updateDeckDisplay();
                updateAddButtons();
            }
        }
        
        function clearDeck() {
            showAppConfirm('Are you sure you want to clear your deck?').then(ok => {
                if(!ok) return;
                playerDeck = [];
                updateDeckStats();
                updateDeckDisplay();
                updateAddButtons();
            });
        }
        
        function playAllCardsToBoard() {
            if (playerDeck.length === 0) { showAppAlert('No cards in deck to play!'); return; }
            showAppConfirm(`Play all ${playerDeck.length} cards from your deck to the board?`).then(ok => {
                if(!ok) return;
            
            showProcessingIndicator('playCards', `Playing cards to board... (0/${playerDeck.length})`, 0);
            
            let cardsPlayed = 0;
            playerDeck.forEach((deckCard, index) => {
                // Small delay between each card to avoid overwhelming the render queue
                setTimeout(() => {
                    playCardToBoard(deckCard.id);
                    cardsPlayed++;
                    
                    const progress = Math.round((cardsPlayed / playerDeck.length) * 100);
                    updateProcessingIndicator('playCards', `Playing cards to board... (${cardsPlayed}/${playerDeck.length})`, progress);
                    
                    // Show progress for large decks
                    if (cardsPlayed === playerDeck.length) {
                        toast(`All ${cardsPlayed} cards played to board!`);
                        setTimeout(() => hideProcessingIndicator('playCards'), 1000);
                    }
                }, index * 50); // 50ms delay between each card
            });
            
                // Optionally clear after
                showAppConfirm('Clear the deck after playing all cards?').then(cOk => { if(cOk) setTimeout(clearDeck, playerDeck.length * 50 + 100); });
            });
        }
        
        function updateDeckStats() {
            deckCount.textContent = playerDeck.length;
            
            // Calculate average cost
            const totalCost = playerDeck.reduce((sum, card) => {
                const cost = card.cost ? parseFloat(card.cost.match(/\d+/)?.[0] || 0) : 0;
                return sum + cost;
            }, 0);
            avgCost.textContent = playerDeck.length > 0 ? (totalCost / playerDeck.length).toFixed(1) : '0';
            
            // Count card types
            const monsters = playerDeck.filter(c => c.type === 'Monster Card' || c.type === 'Student Card').length;
            const spells = playerDeck.filter(c => c.type === 'Spell Card').length;
            const items = playerDeck.filter(c => c.type === 'Item Card' || c.type === 'Artifact Card' || c.type === 'Booster Card').length;
            
            deckMonsters.textContent = monsters;
            deckSpells.textContent = spells;
            deckItems.textContent = items;
            
            // Show/hide export button based on deck completeness
            if (playerDeck.length === 55) {
                exportPngBtn.style.display = 'inline-block';
            } else {
                exportPngBtn.style.display = 'none';
            }
        }
        
        function updateDeckDisplay() {
            if (!deckVisible) return;
            
            // Group cards by ID and count
            const cardCounts = {};
            playerDeck.forEach(card => {
                if (cardCounts[card.id]) {
                    cardCounts[card.id].count++;
                    cardCounts[card.id].deckIds.push(card.deckId);
                } else {
                    cardCounts[card.id] = { card: card, count: 1, deckIds: [card.deckId] };
                }
            });
            
            deckContainer.innerHTML = Object.values(cardCounts).map(item => `
                <div class="deck-card">
                    <div class="deck-card-count">${item.count}</div>
                    <div class="deck-card-name">${item.card.name}</div>
                    <div class="deck-card-cost">${item.card.cost || 'Free'}</div>
                    <button onclick="removeFromDeckById('${item.card.id}')" class="card-btn card-btn-danger" style="margin-top: 5px;">Remove One</button>
                </div>
            `).join('');
        }
        
        function updateAddButtons() {
            filteredCards.forEach((card, index) => {
                const uniqueCardId = `${card.id}_${index}`;
                const btn = document.getElementById(`addBtn_${uniqueCardId}`);
                if (btn) {
                    const inDeck = playerDeck.filter(c => c.id === card.id).length;
                    if (inDeck >= 3) {  // Max 3 copies per card
                        btn.disabled = true;
                        btn.textContent = '✓ Max Copies';
                    } else if (playerDeck.length >= 55) {
                        btn.disabled = true;
                        btn.textContent = '⚠️ Deck Full';
                    } else {
                        btn.disabled = false;
                        btn.textContent = `➕ ${inDeck > 0 ? `(${inDeck})` : ''}`;
                    }
                }
            });
        }

        /* ========================= */
        /* Virtual Tabletop Functions */
        /* ========================= */
        const gameBoardZone = document.getElementById('gameBoardZone');
        let topZIndexCounter = 200; // start above base
        let draggingCardEl = null;

        function playCardToBoard(cardId, cardIndex = 0) {
            console.log('playCardToBoard called with cardId:', cardId, 'cardIndex:', cardIndex);
            const card = cards.find(c => c.id === cardId); 
            if(!card) {
                console.error('Card not found for id:', cardId);
                return;
            }
            console.log('Found card:', card.name);
            
            // Use the current art variant for this card instance
            const variants = getArtVariants(card);
            const uniqueId = `${cardId}_${cardIndex}`;
            const artIndex = currentArtIndex[uniqueId] || 0;
            const selectedVariant = variants[artIndex] || card.image_url;
            console.log('Using art variant:', artIndex, selectedVariant);
            
            const graphicId = getGraphicCacheKey(card.id, cardIndex, 'board');
            console.log('Using graphic ID:', graphicId);
            
            // build wrapper
            const wrapper = document.createElement('div');
            wrapper.className = 'card-graphic board-card';
            wrapper.dataset.cardId = card.id;
            wrapper.dataset.cardName = card.name;
            wrapper.dataset.rotation='0';
            wrapper.dataset.flipped='0';
            wrapper.dataset.tapped='0';
            const startX = (20 + Math.random() * (gameBoardZone.clientWidth - 340));
            const startY = (20 + Math.random() * (gameBoardZone.clientHeight - 480));
            wrapper.dataset.x = startX; wrapper.dataset.y = startY;
            
            console.log('Created wrapper, position:', startX, startY);
            
            // Add right-click and hotkey support instead of visible buttons
            setupBoardCardControls(wrapper);
            
            // image (use cache or queue render)
            const cached = graphicCardCache.get(graphicId);
            if (cached) {
                console.log('Using cached image');
                const img = document.createElement('img'); 
                img.src=cached; 
                img.alt=card.name; 
                img.dataset.originalSrc = cached;
                wrapper.appendChild(img);
            } else {
                console.log('Rendering new image for board');
                wrapper.classList.add('loading'); wrapper.textContent='Rendering...';
                (async()=>{ try { const canvas = await renderCardToPNG(card, cardIndex, {mode:'board'}); const dataUrl = canvas.toDataURL('image/png'); graphicCardCache.set(graphicId,dataUrl); wrapper.classList.remove('loading'); wrapper.textContent=''; const img=document.createElement('img'); img.src=dataUrl; img.alt=card.name; img.dataset.originalSrc = dataUrl; wrapper.appendChild(img); console.log('Board card image rendered and added'); } catch(e){ console.error('Board render failed',e); wrapper.textContent='Render fail'; }} )();
            }
            console.log('Adding card to board zone, gameBoardZone:', gameBoardZone);
            gameBoardZone.appendChild(wrapper);
            applyPosition(wrapper);
            wrapper.style.zIndex=(++topZIndexCounter).toString();
            makeCardDraggable(wrapper);
            enableDropTargets(wrapper);
            console.log('Card added to board successfully:', wrapper);
        }
        
        // Setup board card controls with right-click menu and hotkeys
        function setupBoardCardControls(cardEl) {
            // Right-click context menu
            cardEl.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                e.stopPropagation();
                showBoardCardContextMenu(e.clientX, e.clientY, cardEl);
            });
            
            // Hold detection for hotkeys
            let holdTimer = null;
            let isHolding = false;
            
            cardEl.addEventListener('pointerdown', (e) => {
                // Don't interfere with dragging
                if (e.button !== 0) return;
                
                holdTimer = setTimeout(() => {
                    isHolding = true;
                    showHoldHotkeys(cardEl);
                }, 500); // 500ms hold to activate hotkeys
            });
            
            cardEl.addEventListener('pointerup', () => {
                if (holdTimer) clearTimeout(holdTimer);
                if (isHolding) {
                    hideHoldHotkeys();
                    isHolding = false;
                }
            });
            
            cardEl.addEventListener('pointermove', () => {
                // Cancel hold if user starts dragging
                if (holdTimer) {
                    clearTimeout(holdTimer);
                    holdTimer = null;
                }
            });
        }
        
        // Show context menu for board card
        function showBoardCardContextMenu(x, y, cardEl) {
            const contextMenu = document.getElementById('boardContextMenu');
            contextMenu.innerHTML = '';
            
            const addBtn = (icon, label, handler) => {
                const btn = document.createElement('div');
                btn.className = 'context-menu-item';
                btn.innerHTML = `${icon} ${label}`;
                btn.addEventListener('click', () => {
                    handler();
                    hideContextMenu();
                });
                contextMenu.appendChild(btn);
            };
            
            addBtn('↪️', 'Tap/Untap (T)', () => tapCard(cardEl));
            addBtn('🔄', 'Rotate (R)', () => rotateCard(cardEl));
            addBtn('🔃', 'Flip (F)', () => flipCard(cardEl));
            addBtn('🗑️', 'Remove (Delete)', () => cardEl.remove());
            addBtn('📋', 'Clone (C)', () => {
                const cardId = cardEl.dataset.cardId;
                if (cardId) playCardToBoard(cardId);
            });
            
            contextMenu.classList.remove('hidden');
            contextMenu.style.left = x + 'px';
            contextMenu.style.top = y + 'px';
            
            // Auto-hide after 5 seconds
            setTimeout(() => hideContextMenu(), 5000);
        }
        
        // Show hold hotkeys overlay
        function showHoldHotkeys(cardEl) {
            // Remove any existing overlay
            const existingOverlay = document.querySelector('.hold-hotkeys-overlay');
            if (existingOverlay) existingOverlay.remove();
            
            const overlay = document.createElement('div');
            overlay.className = 'hold-hotkeys-overlay';
            overlay.innerHTML = `
                <div class="hotkey-hint">
                    <span class="hotkey">T</span> Tap/Untap
                </div>
                <div class="hotkey-hint">
                    <span class="hotkey">R</span> Rotate
                </div>
                <div class="hotkey-hint">
                    <span class="hotkey">F</span> Flip
                </div>
                <div class="hotkey-hint">
                    <span class="hotkey">C</span> Clone
                </div>
                <div class="hotkey-hint">
                    <span class="hotkey">Del</span> Remove
                </div>
                <div class="hotkey-hint">
                    <span class="hotkey">S</span> Shrink/Restore 75%
                </div>
            `;
            
            // Position near the card
            const rect = cardEl.getBoundingClientRect();
            overlay.style.left = (rect.left + rect.width + 10) + 'px';
            overlay.style.top = rect.top + 'px';
            
            document.body.appendChild(overlay);
            
            // Set up hotkey listeners
            setupHotkeys(cardEl);
        }
        
        // Hide hold hotkeys overlay
        function hideHoldHotkeys() {
            const overlay = document.querySelector('.hold-hotkeys-overlay');
            if (overlay) overlay.remove();
            
            // Remove hotkey listeners
            document.removeEventListener('keydown', activeHotkeyHandler);
        }
        
        let activeHotkeyHandler = null;
        let activeCard = null;
        
        // Setup hotkey listeners for a specific card
        function setupHotkeys(cardEl) {
            activeCard = cardEl;
            
            activeHotkeyHandler = (e) => {
                if (!activeCard) return;
                
                e.preventDefault();
                e.stopPropagation();
                
                switch(e.key.toLowerCase()) {
                    case 't':
                        tapCard(activeCard);
                        break;
                    case 'r':
                        rotateCard(activeCard);
                        break;
                    case 'f':
                        flipCard(activeCard);
                        break;
                    case 'c':
                        const cardId = activeCard.dataset.cardId;
                        if (cardId) playCardToBoard(cardId);
                        break;
                    case 's':
                        // Toggle shrink state
                        const isShrunk = activeCard.dataset.shrunk === '1';
                        activeCard.dataset.shrunk = isShrunk ? '0' : '1';
                        // Store original scale (implicitly 1). Apply 0.75 when shrunk.
                        applyPosition(activeCard);
                        break;
                    case 'delete':
                    case 'backspace':
                        activeCard.remove();
                        break;
                }
                
                hideHoldHotkeys();
            };
            
            document.addEventListener('keydown', activeHotkeyHandler);
        }        function applyPosition(cardEl){
            const x = parseFloat(cardEl.dataset.x||'0');
            const y = parseFloat(cardEl.dataset.y||'0');
            const rot = cardEl.dataset.rotation || '0';
            const flipped = cardEl.dataset.flipped === '1';
            // Don't apply any scaleX transform when showing card back - card back should never be mirrored
            const flipPart = '';
            const scale = cardEl.dataset.shrunk === '1' ? 0.75 : 1;
            cardEl.style.transform = `translate(${x}px, ${y}px) rotate(${rot}deg) scale(${scale})` + flipPart;
        }

        function enableDropTargets(cardEl) {
            const zones = ['discardZone']; // Only The Pail remains
            zones.forEach(id => {
                const zone = document.getElementById(id);
                if (!zone || zone._vtInitialized) return;
                
                zone.addEventListener('dragover', (e) => { e.preventDefault(); zone.style.borderColor = '#fae791'; });
                zone.addEventListener('dragleave', () => { zone.style.borderColor = '#97740a'; });
                zone.addEventListener('drop', (e) => {
                    e.preventDefault();
                    if (draggingCardEl) {
                        zone.style.borderColor = '#97740a';
                        
                        // Special handling for discard zone - automatically add to deck
                        if (id === 'discardZone') {
                            const cardId = draggingCardEl.dataset.cardId;
                            const card = cards.find(c => c.id === cardId);
                            if (card) {
                                // Add card data to deck
                                boardDeck.push({
                                    cardData: card,
                                    cardId: cardId,
                                    tapped: draggingCardEl.dataset.tapped === '1',
                                    flipped: draggingCardEl.dataset.flipped === '1',
                                    rotation: draggingCardEl.dataset.rotation || '0'
                                });
                                
                                // Remove card from board
                                draggingCardEl.remove();
                                
                                // Update deck pile and show toast
                                createDeckPile();
                                toast('Card added to deck');
                                
                                draggingCardEl = null;
                                return;
                            }
                        }
                        
                        // Default behavior for other zones - just move card there
                        zone.appendChild(draggingCardEl);
                        draggingCardEl.style.position = 'relative';
                        draggingCardEl.style.left = '';
                        draggingCardEl.style.top = '';
                        draggingCardEl.setAttribute('draggable', 'false');
                        arrangeZone(zone);
                        draggingCardEl = null;
                    }
                });
                zone._vtInitialized = true;
            });
        }

        function rotateCard(cardEl) {
            console.log('rotateCard called with:', cardEl);
            if (!cardEl) return;
            const current = parseInt(cardEl.dataset.rotation || '0', 10);
            const next = (current + 90) % 360;
            cardEl.dataset.rotation = next.toString();
            console.log('Rotating card to:', next);
            applyPosition(cardEl);
        }

        function flipCard(cardEl) {
            console.log('flipCard called with:', cardEl);
            if (!cardEl) return;
            const isFlipped = cardEl.dataset.flipped === '1';
            cardEl.dataset.flipped = isFlipped ? '0' : '1';
            console.log('Flipping card, isFlipped was:', isFlipped, 'now:', !isFlipped);
            
            // If flipping to back, show cardback.png; if flipping to front, show original image
            const img = cardEl.querySelector('img');
            if(img) {
                if(!isFlipped) {
                    // Flipping to back - store original src and show cardback
                    if(!img.dataset.originalSrc) {
                        img.dataset.originalSrc = img.src;
                    }
                    img.src = 'src/assets/images/expeditionandgames/TCG Images/cardback.png';
                    img.alt = 'Card Back';
                    console.log('Showing card back');
                } else {
                    // Flipping to front - restore original image
                    if(img.dataset.originalSrc) {
                        img.src = img.dataset.originalSrc;
                        img.alt = cardEl.dataset.cardName || 'Card';
                        console.log('Restoring original image');
                    }
                }
            }
            
            applyPosition(cardEl);
        }

        function applyTransform(cardEl){ applyPosition(cardEl); }
        /* ===== Advanced Board Features ===== */
        const BOARD_STORAGE_KEY = 'tcgBoardState_v1';
        let snapToGrid = false;
        let gridSize = 20;
        let multiSelect = new Set();
        let selectionRect = null;
        let selectionStart = null;
        const contextMenu = document.getElementById('boardContextMenu');
        
        // Deck management state
        let boardDeck = []; // Face-down deck on the board
        let deckPosition = { x: 50, y: 50 }; // Default deck position
        let isDeckVisible = false;
        
        // Life counter state
        let lifeCounterValue = 10;

        // Placeable zones state
        let placeableZones = [];
        let zoneIdCounter = 1;

        // ===============================
        // ZONE LAYOUT (VISIBLE SOURCE CODE)
        // These are the board zones taken from board-state2.json so you can SEE them here.
        // Adjust positions/sizes/labels as needed; they will be seeded on first load if no saved board.
        // ===============================
        const DEFAULT_ZONES = [
            { id: 'zone_1',  x: 982,  y: 869.9999847412109,  width: 200, height: 300, label: 'Boosters' },
            { id: 'zone_2',  x: 1303, y: 873.9999847412109,  width: 200, height: 300, label: 'Boosters' },
            { id: 'zone_3',  x: 1680, y: 871.9999847412109,  width: 200, height: 300, label: 'Boosters' },
            { id: 'zone_4',  x: 757,  y: 460.99998474121094, width: 200, height: 300, label: 'Back Row' },
            { id: 'zone_5',  x: 1242, y: 456.99998474121094, width: 200, height: 300, label: 'Back Row' },
            { id: 'zone_6',  x: 1674, y: 457.99998474121094, width: 200, height: 300, label: 'Back Row' },
            { id: 'zone_7',  x: 748,  y: 44.99998474121094,  width: 200, height: 300, label: 'Front Row' },
            { id: 'zone_8',  x: 1230, y: 43.99998474121094,  width: 200, height: 300, label: 'Front Row' },
            { id: 'zone_9',  x: 1668, y: 46.99998474121094,  width: 200, height: 300, label: 'Front Row' },
            { id: 'zone_10', x: 395,  y: 456.99998474121094, width: 200, height: 300, label: 'Artifacts' },
            { id: 'zone_11', x: 75,   y: 454.99998474121094, width: 200, height: 300, label: 'Spells' },
            { id: 'zone_12', x: 2158, y: 459.99998474121094, width: 200, height: 300, label: 'Environment' }
        ];
        // ===============================

        function createPlaceableZone(x = 300, y = 200, label = 'New Zone') {
            const zone = {
                id: `zone_${zoneIdCounter++}`,
                x: x,
                y: y,
                width: 180,
                height: 270,
                label: label
            };
            
            placeableZones.push(zone);
            renderPlaceableZone(zone);
            saveBoardState(); // Auto-save when zones are created
            return zone;
        }
        
        function renderPlaceableZone(zone) {
            const zoneEl = document.createElement('div');
            zoneEl.className = 'placeable-zone';
            zoneEl.dataset.zoneId = zone.id;
            zoneEl.id = zone.id; // allow direct lookup by id
            zoneEl.style.left = zone.x + 'px';
            zoneEl.style.top = zone.y + 'px';
            zoneEl.style.width = zone.width + 'px';
            zoneEl.style.height = zone.height + 'px';
            zoneEl.textContent = zone.label;
            
            // Double-click to edit label
            zoneEl.addEventListener('dblclick', (e) => {
                e.stopPropagation();
                editZoneLabel(zone, zoneEl);
            });
            
            // Right-click for zone options
            zoneEl.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                e.stopPropagation();
                showZoneContextMenu(e.clientX, e.clientY, zone);
            });
            
            // Make zone draggable
            makeZoneDraggable(zoneEl, zone);
            
            gameBoardZone.appendChild(zoneEl);
        }
        
        function editZoneLabel(zone, zoneEl) {
            const input = document.createElement('input');
            input.type = 'text';
            input.value = zone.label;
            input.className = 'zone-input';
            input.style.width = (zone.width - 20) + 'px';
            
            zoneEl.innerHTML = '';
            zoneEl.appendChild(input);
            zoneEl.classList.add('editing');
            input.focus();
            input.select();
            
            const finishEdit = () => {
                zone.label = input.value || 'Zone';
                zoneEl.classList.remove('editing');
                zoneEl.textContent = zone.label;
                saveBoardState();
            };
            
            input.addEventListener('blur', finishEdit);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') finishEdit();
                if (e.key === 'Escape') {
                    zoneEl.classList.remove('editing');
                    zoneEl.textContent = zone.label;
                }
            });
        }
        
        function makeZoneDraggable(zoneEl, zone) {
            let isDragging = false;
            let dragOffset = { x: 0, y: 0 };
            
            zoneEl.addEventListener('pointerdown', (e) => {
                if (e.target.tagName === 'INPUT') return; // Don't drag when editing
                
                isDragging = true;
                const rect = zoneEl.getBoundingClientRect();
                const boardRect = gameBoardZone.getBoundingClientRect();
                dragOffset.x = e.clientX - rect.left;
                dragOffset.y = e.clientY - rect.top;
                
                zoneEl.style.zIndex = '999';
                e.preventDefault();
            });
            
            document.addEventListener('pointermove', (e) => {
                if (!isDragging) return;
                
                const boardRect = gameBoardZone.getBoundingClientRect();
                const newX = e.clientX - boardRect.left - dragOffset.x;
                const newY = e.clientY - boardRect.top - dragOffset.y;
                
                zone.x = Math.max(0, Math.min(newX, gameBoardZone.clientWidth - zone.width));
                zone.y = Math.max(0, Math.min(newY, gameBoardZone.clientHeight - zone.height));
                
                zoneEl.style.left = zone.x + 'px';
                zoneEl.style.top = zone.y + 'px';
            });
            
            document.addEventListener('pointerup', () => {
                if (isDragging) {
                    isDragging = false;
                    zoneEl.style.zIndex = '10';
                    saveBoardState();
                }
            });
        }
        
        function showZoneContextMenu(x, y, zone) {
            const contextMenu = document.getElementById('boardContextMenu');
            contextMenu.innerHTML = '';
            
            const addBtn = (icon, label, handler) => {
                const btn = document.createElement('button');
                btn.innerHTML = `${icon} ${label}`;
                btn.style.cssText = `display: block; width: 100%; padding: 8px 16px; border: none; background: transparent; color: var(--ink); text-align: left; cursor: pointer; font-family: serif; font-size: 14px;`;
                btn.addEventListener('mouseover', () => btn.style.backgroundColor = 'var(--gold-dark)');
                btn.addEventListener('mouseout', () => btn.style.backgroundColor = 'transparent');
                btn.addEventListener('click', handler);
                contextMenu.appendChild(btn);
            };
            
            addBtn('✏️', 'Edit Label', () => {
                const zoneEl = gameBoardZone.querySelector(`[data-zone-id="${zone.id}"]`);
                if (zoneEl) editZoneLabel(zone, zoneEl);
                hideContextMenu();
            });
            
            addBtn('🗑️', 'Delete Zone', () => {
                showAppConfirm(`Delete zone "${zone.label}"?`).then(ok => { if (ok) deletePlaceableZone(zone.id); });
                hideContextMenu();
            });
            
            contextMenu.classList.remove('hidden');
            contextMenu.style.left = x + 'px';
            contextMenu.style.top = y + 'px';
        }
        
        function deletePlaceableZone(zoneId) {
            placeableZones = placeableZones.filter(z => z.id !== zoneId);
            const zoneEl = gameBoardZone.querySelector(`[data-zone-id="${zoneId}"]`);
            if (zoneEl) zoneEl.remove();
            saveBoardState();
        }

        function toggleSnap() {
            snapToGrid = !snapToGrid;
            document.getElementById('snapToggleBtn').classList.toggle('active', snapToGrid);
        }
        function snap(value) { return Math.round(value / gridSize) * gridSize; }

        function saveBoardState() {
            const cardsOnBoard = [...gameBoardZone.querySelectorAll('.board-card')].filter(c => !c.closest('.token-zone') && !c.classList.contains('deck-pile'));
            const state = {
                cards: cardsOnBoard.map(c => ({
                    id: c.dataset.cardId,
                    x: c.dataset.x || '0',
                    y: c.dataset.y || '0',
                    rotation: c.dataset.rotation || '0',
                    flipped: c.dataset.flipped || '0',
                    z: c.style.zIndex
                })),
                deck: {
                    cards: boardDeck,
                    position: deckPosition,
                    visible: isDeckVisible
                },
                zones: placeableZones
            };
            localStorage.setItem(BOARD_STORAGE_KEY, JSON.stringify(state));
            toast('Board, deck, and zones saved.');
        }

        function loadBoardState() {
            const raw = localStorage.getItem(BOARD_STORAGE_KEY);
            if (!raw) { toast('No saved board.'); return; }
            try {
                const state = JSON.parse(raw);
                
                // Handle legacy format (just array of cards)
                if (Array.isArray(state)) {
                    [...gameBoardZone.querySelectorAll('.board-card')].forEach(c => { if (!c.closest('.token-zone')) c.remove(); });
                    state.forEach(entry => {
                        playCardToBoard(entry.id);
                        const cardEl = [...gameBoardZone.querySelectorAll('.board-card')].slice(-1)[0];
                        if (cardEl) {
                            cardEl.dataset.x = (entry.x || parseFloat(entry.left)||0).toString();
                            cardEl.dataset.y = (entry.y || parseFloat(entry.top)||0).toString();
                            cardEl.style.zIndex = entry.z || (++topZIndexCounter).toString();
                            cardEl.dataset.rotation = entry.rotation;
                            cardEl.dataset.flipped = entry.flipped;
                            applyPosition(cardEl);
                        }
                    });
                    toast('Board loaded (legacy format).');
                    return;
                }
                
                // Clear current board and deck
                [...gameBoardZone.querySelectorAll('.board-card')].forEach(c => { if (!c.closest('.token-zone')) c.remove(); });
                const existingDeck = gameBoardZone.querySelector('.deck-pile');
                if (existingDeck) existingDeck.remove();
                
                // Load board cards
                if (state.cards) {
                    state.cards.forEach(entry => {
                        playCardToBoard(entry.id);
                        const cardEl = [...gameBoardZone.querySelectorAll('.board-card')].slice(-1)[0];
                        if (cardEl) {
                            cardEl.dataset.x = (entry.x || parseFloat(entry.left)||0).toString();
                            cardEl.dataset.y = (entry.y || parseFloat(entry.top)||0).toString();
                            cardEl.style.zIndex = entry.z || (++topZIndexCounter).toString();
                            cardEl.dataset.rotation = entry.rotation;
                            cardEl.dataset.flipped = entry.flipped;
                            applyPosition(cardEl);
                        }
                    });
                }
                
                // Load deck state
                if (state.deck) {
                    boardDeck = state.deck.cards || [];
                    deckPosition = state.deck.position || { x: 50, y: 50 };
                    isDeckVisible = state.deck.visible || false;
                    if (boardDeck.length > 0) {
                        createDeckPile();
                    }
                }
                
                // Load zones
                placeableZones = [];
                [...gameBoardZone.querySelectorAll('.placeable-zone')].forEach(z => z.remove());
                if (state.zones) {
                    placeableZones = state.zones;
                    placeableZones.forEach(zone => renderPlaceableZone(zone));
                }
                
                toast('Board, deck, and zones loaded.');
            } catch(e) { console.error(e); toast('Load failed'); }
        }

        function clearBoard() {
            showAppConfirm('Clear all cards from board?').then(ok => {
                if (!ok) return;
                [...gameBoardZone.querySelectorAll('.board-card')].forEach(c => { if (!c.closest('.token-zone')) c.remove(); });
                multiSelect.clear();
            });
        }

        function toast(msg) {
            const el = document.createElement('div');
            el.textContent = msg;
            el.style.cssText = 'position:fixed;bottom:20px;right:20px;background:#1E1C12;color:var(--gold-light);padding:8px 14px;border:1px solid var(--gold-dark);border-radius:6px;font-size:0.8rem;z-index:2000;';
            document.body.appendChild(el);
            setTimeout(()=>el.remove(),2000);
        }

        // In-app styled prompt (replaces window.prompt for Electron compatibility)
        function showAppPrompt(message, defaultValue = '', opts = {}) {
            return new Promise(resolve => {
                // Remove existing if present
                const existing = document.getElementById('appPromptDialog');
                if (existing) existing.remove();
                const overlay = document.createElement('div');
                overlay.id = 'appPromptDialog';
                overlay.style.cssText = 'position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.55);z-index:3000;font-family:serif;';
                const panel = document.createElement('div');
                panel.style.cssText = 'background:var(--parchment,#f5e6c8);color:var(--ink,#1E1C12);border:2px solid var(--gold,#b68c1b);padding:18px 22px;max-width:360px;width:100%;border-radius:10px;box-shadow:0 6px 18px rgba(0,0,0,0.35);';
                panel.innerHTML = `
                    <div style="font-weight:600;margin-bottom:12px;font-size:1rem;line-height:1.3;">${message}</div>
                    <input type="number" id="appPromptInput" value="${defaultValue}" style="width:100%;padding:8px 10px;border:1px solid var(--gold-dark,#97740a);border-radius:6px;background:#fff9ed;font-size:0.95rem;font-family:serif;margin-bottom:14px;" />
                    <div style="display:flex;gap:10px;justify-content:flex-end;">
                        <button id="appPromptCancel" style="background:#6b5330;color:#fce7b2;border:1px solid #4d3c22;padding:6px 14px;border-radius:6px;cursor:pointer;font-family:serif;">Cancel</button>
                        <button id="appPromptOk" style="background:#b68c1b;color:#1E1C12;border:1px solid #8a6813;padding:6px 16px;border-radius:6px;cursor:pointer;font-weight:600;font-family:serif;">OK</button>
                    </div>`;
                overlay.appendChild(panel);
                document.body.appendChild(overlay);
                const input = panel.querySelector('#appPromptInput');
                const btnOk = panel.querySelector('#appPromptOk');
                const btnCancel = panel.querySelector('#appPromptCancel');
                if (opts.max) {
                    input.min = '1';
                    input.max = String(opts.max);
                }
                const close = (val)=>{ overlay.remove(); resolve(val); };
                btnOk.addEventListener('click',()=> close(input.value.trim()));
                btnCancel.addEventListener('click',()=> close(null));
                overlay.addEventListener('click', (e)=>{ if(e.target===overlay) close(null); });
                input.addEventListener('keydown',(e)=>{ if(e.key==='Enter') close(input.value.trim()); if(e.key==='Escape') close(null); });
                input.focus(); input.select();
            });
        }

        // In-app styled alert (non-blocking replacement for window.alert)
        function showAppAlert(message, { title = 'Notice', okText = 'OK' } = {}) {
            return new Promise(resolve => {
                const existing = document.getElementById('appAlertDialog'); if (existing) existing.remove();
                const overlay = document.createElement('div');
                overlay.id = 'appAlertDialog';
                overlay.style.cssText = 'position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.55);z-index:4000;font-family:serif;';
                const panel = document.createElement('div');
                panel.style.cssText = 'background:var(--parchment,#f5e6c8);color:var(--ink,#1E1C12);border:2px solid var(--gold,#b68c1b);padding:20px 24px;max-width:440px;width:100%;border-radius:12px;box-shadow:0 6px 18px rgba(0,0,0,0.35);';
                panel.innerHTML = `<div style="font-weight:700;margin-bottom:12px;font-size:1.05rem;">${title}</div><div style="white-space:pre-wrap;line-height:1.4;margin-bottom:20px;font-size:.95rem;">${message.replace(/\n/g,'<br>')}</div><div style="text-align:right;"><button id="appAlertOk" style="background:#b68c1b;color:#1E1C12;border:1px solid #8a6813;padding:8px 20px;border-radius:8px;cursor:pointer;font-weight:600;font-family:serif;">${okText}</button></div>`;
                overlay.appendChild(panel); document.body.appendChild(overlay);
                const okBtn = panel.querySelector('#appAlertOk');
                const close = () => { overlay.remove(); resolve(); };
                okBtn.addEventListener('click', close);
                overlay.addEventListener('click', e => { if (e.target === overlay) close(); });
                document.addEventListener('keydown', function handler(e){ if(e.key==='Escape' || e.key==='Enter'){ document.removeEventListener('keydown', handler); close(); }});
            });
        }

        // In-app styled confirm (non-blocking replacement for window.confirm)
        function showAppConfirm(message, { title = 'Confirm', okText = 'OK', cancelText = 'Cancel' } = {}) {
            return new Promise(resolve => {
                const existing = document.getElementById('appConfirmDialog'); if (existing) existing.remove();
                const overlay = document.createElement('div');
                overlay.id = 'appConfirmDialog';
                overlay.style.cssText = 'position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.55);z-index:4000;font-family:serif;';
                const panel = document.createElement('div');
                panel.style.cssText = 'background:var(--parchment,#f5e6c8);color:var(--ink,#1E1C12);border:2px solid var(--gold,#b68c1b);padding:22px 26px;max-width:460px;width:100%;border-radius:12px;box-shadow:0 6px 18px rgba(0,0,0,0.35);';
                panel.innerHTML = `<div style=\"font-weight:700;margin-bottom:12px;font-size:1.05rem;\">${title}</div><div style=\"white-space:pre-wrap;line-height:1.4;margin-bottom:24px;font-size:.95rem;\">${message.replace(/\n/g,'<br>')}</div><div style=\"display:flex;gap:12px;justify-content:flex-end;\"><button id=\"appConfirmCancel\" style=\"background:#6b5330;color:#fce7b2;border:1px solid #4d3c22;padding:8px 18px;border-radius:8px;cursor:pointer;font-family:serif;\">${cancelText}</button><button id=\"appConfirmOk\" style=\"background:#b68c1b;color:#1E1C12;border:1px solid #8a6813;padding:8px 22px;border-radius:8px;cursor:pointer;font-weight:600;font-family:serif;\">${okText}</button></div>`;
                overlay.appendChild(panel); document.body.appendChild(overlay);
                const okBtn = panel.querySelector('#appConfirmOk');
                const cancelBtn = panel.querySelector('#appConfirmCancel');
                const settle = val => { overlay.remove(); resolve(val); };
                okBtn.addEventListener('click', () => settle(true));
                cancelBtn.addEventListener('click', () => settle(false));
                overlay.addEventListener('click', e => { if (e.target === overlay) settle(false); });
                document.addEventListener('keydown', function handler(e){ if(e.key==='Escape'){ document.removeEventListener('keydown', handler); settle(false);} if(e.key==='Enter'){ document.removeEventListener('keydown', handler); settle(true);} });
            });
        }

        function toggleSelect(cardEl, additive=false) {
            if (!additive) multiSelect.clear();
            if (multiSelect.has(cardEl)) multiSelect.delete(cardEl); else multiSelect.add(cardEl);
            refreshSelectionStyles();
        }
        function clearSelection() { multiSelect.clear(); refreshSelectionStyles(); }
        function refreshSelectionStyles() {
            [...gameBoardZone.querySelectorAll('.board-card')].forEach(c => c.classList.remove('board-card-selected'));
            multiSelect.forEach(c => c.classList.add('board-card-selected'));
        }

        gameBoardZone.addEventListener('pointerdown', (e) => {
            if (e.target === gameBoardZone) {
                clearSelection();
                selectionStart = { x: e.clientX, y: e.clientY };
                selectionRect = document.createElement('div');
                selectionRect.className = 'selection-rect';
                gameBoardZone.appendChild(selectionRect);
            }
        });
        window.addEventListener('pointermove', (e) => {
            if (!selectionStart || !selectionRect) return;
            const boardRect = gameBoardZone.getBoundingClientRect();
            const x1 = Math.min(selectionStart.x, e.clientX) - boardRect.left;
            const y1 = Math.min(selectionStart.y, e.clientY) - boardRect.top;
            const x2 = Math.max(selectionStart.x, e.clientX) - boardRect.left;
            const y2 = Math.max(selectionStart.y, e.clientY) - boardRect.top;
            selectionRect.style.left = x1 + 'px';
            selectionRect.style.top = y1 + 'px';
            selectionRect.style.width = (x2 - x1) + 'px';
            selectionRect.style.height = (y2 - y1) + 'px';
            const rectSel = { left:x1, top:y1, right:x2, bottom:y2 };
            multiSelect.clear();
            [...gameBoardZone.querySelectorAll('.board-card')].forEach(c => {
                const r = c.getBoundingClientRect();
                const br = gameBoardZone.getBoundingClientRect();
                const cx1 = r.left - br.left; const cy1 = r.top - br.top; const cx2 = cx1 + r.width; const cy2 = cy1 + r.height;
                if (cx1 < rectSel.right && cx2 > rectSel.left && cy1 < rectSel.bottom && cy2 > rectSel.top) multiSelect.add(c);
            });
            refreshSelectionStyles();
        });
        window.addEventListener('pointerup', () => {
            if (selectionRect) selectionRect.remove();
            selectionRect = null; selectionStart = null;
        });

        gameBoardZone.addEventListener('click', (e) => {
            const card = e.target.closest('.board-card');
            if (card && !card.closest('.token-zone')) {
                if (e.shiftKey) { toggleSelect(card, true); e.stopPropagation(); }
            }
        }, true);

        gameBoardZone.addEventListener('contextmenu', (e) => {
            const card = e.target.closest('.board-card');
            if (card) {
                if (!multiSelect.has(card)) { multiSelect.clear(); multiSelect.add(card); refreshSelectionStyles(); }
                showContextMenu(e.clientX, e.clientY);
            } else { showContextMenu(e.clientX, e.clientY); }
            e.preventDefault();
        });
            const cardsOnBoard = [...gameBoardZone.querySelectorAll('.board-card')];
        window.addEventListener('click', () => hideContextMenu());

        function showContextMenu(x, y) {
            contextMenu.innerHTML = '';
            const addBtn = (icon, label, handler) => {
                const b = document.createElement('button');
                b.innerHTML = icon + ' ' + label;
                b.onclick = (ev) => { ev.stopPropagation(); hideContextMenu(); handler(); };
                contextMenu.appendChild(b);
            };
            if (multiSelect.size > 0) {
                addBtn('🔄','Rotate 90°', () => multiSelect.forEach(c => { c.dataset.rotation = ((parseInt(c.dataset.rotation||'0')+90)%360).toString(); applyTransform(c); }));
                addBtn('🔃','Flip', () => multiSelect.forEach(c => { c.dataset.flipped = c.dataset.flipped==='1'?'0':'1'; applyTransform(c); }));
                addBtn('📚','Stack', stackSelected);
                addBtn('📤','Unstack', unstackSelected);
                addBtn('⬆️','Bring Front', () => multiSelect.forEach(c => c.style.zIndex = (++topZIndexCounter).toString()));
                addBtn('🗑️','Remove', () => { multiSelect.forEach(c => c.remove()); multiSelect.clear(); });
            } else { addBtn('💬','No selection', () => {}); }
            contextMenu.classList.remove('hidden');
            contextMenu.style.left = x + 'px';
            contextMenu.style.top = y + 'px';
        }
        function hideContextMenu() { contextMenu.classList.add('hidden'); }

        function stackSelected() {
            if (multiSelect.size < 2) { toast('Select 2+ cards'); return; }
            const arr = [...multiSelect];
            const base = arr[0];
            const baseLeft = parseFloat(base.dataset.x||'0');
            const baseTop = parseFloat(base.dataset.y||'0');
            arr.slice(1).forEach((c,i) => {
                c.dataset.x = (baseLeft + 1 + i*2).toString();
                c.dataset.y = (baseTop + 1 + i*2).toString();
                applyPosition(c);
                c.style.zIndex = (parseInt(base.style.zIndex||'200') + i + 1).toString();
            });
            toast('Stacked');
        }
        function unstackSelected() {
            if (multiSelect.size === 0) { toast('No selection'); return; }
            let offset = 0;
            multiSelect.forEach(c => {
                const left = parseFloat(c.dataset.x||'0');
                const top = parseFloat(c.dataset.y||'0');
                c.dataset.x = (left + offset).toString();
                c.dataset.y = (top + offset).toString();
                applyPosition(c);
                offset += 30;
            });
            toast('Unstacked');
        }

        function applySnapIfNeeded(cardEl) {
            if (!snapToGrid) return;
            const x = parseFloat(cardEl.dataset.x || '0');
            const y = parseFloat(cardEl.dataset.y || '0');
            const nx = snap(x);
            const ny = snap(y);
            cardEl.dataset.x = nx.toString();
            cardEl.dataset.y = ny.toString();
            applyPosition(cardEl);
        }

        /* ===== Additional Advanced Features (Grid / Export / Arrange) ===== */
        const gridOverlayEl = document.getElementById('boardGridOverlay');
        let gridVisible = false;

        function updateGridOverlay() {
            if (!gridOverlayEl) return;
            const size = gridSize; // reuse snap grid size
            gridOverlayEl.style.backgroundSize = `${size}px ${size}px`;
        }

        function toggleGrid() {
            gridVisible = !gridVisible;
            if (gridOverlayEl) {
                gridOverlayEl.style.display = gridVisible ? 'block' : 'none';
            }
            document.getElementById('gridToggleBtn').classList.toggle('active', gridVisible);
            updateGridOverlay();
        }

        function getBoardState(includeZones = true) {
            const entries = [];
            // Look for board-card class instead of card class
            const all = [...gameBoardZone.querySelectorAll('.board-card')];
            all.forEach(c => {
                // Skip deck pile
                if (c.classList.contains('deck-pile')) return;
        // Prefer new placeable zones; fallback to legacy .token-zone
        let parentZone = c.closest('.placeable-zone');
        if (!parentZone) parentZone = c.closest('.token-zone');
        const inZone = !!parentZone;
        if (!inZone) {
                    entries.push({
                        id: c.dataset.cardId,
                        x: c.dataset.x || '0',
                        y: c.dataset.y || '0',
                        rotation: c.dataset.rotation || '0',
                        flipped: c.dataset.flipped || '0',
                        z: c.style.zIndex
                    });
                } else if (includeZones) {
                    entries.push({
            id: c.dataset.cardId,
            zone: parentZone.id || parentZone.dataset.zoneId,
                        rotation: c.dataset.rotation || '0',
                        flipped: c.dataset.flipped || '0'
                    });
                }
            });
            return entries;
        }

        function exportBoardJSON() {
            const data = JSON.stringify({ 
                v: 1, 
                gridSize, 
                snapToGrid, 
                cards: getBoardState(true),
                zones: placeableZones
            }, null, 2);
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url; a.download = 'board-state.json'; a.click();
            URL.revokeObjectURL(url);
            toast('Board exported with zones');
        }

        function importBoardJSON() {
            const input = document.createElement('input');
            input.type = 'file'; input.accept = '.json,application/json';
            input.onchange = e => {
                const file = e.target.files[0]; if (!file) return;
                const reader = new FileReader();
                reader.onload = ev => {
                    try {
                        const parsed = JSON.parse(ev.target.result);
                        restoreBoardFromData(parsed);
                        toast('Board imported');
                    } catch(err) { showAppAlert('Import failed: '+ err.message); }
                };
                reader.readAsText(file);
            };
            input.click();
        }

        function restoreBoardFromData(data) {
            if (!data || !Array.isArray(data.cards)) return;
            // Clear existing non-zone cards
            [...gameBoardZone.querySelectorAll('.board-card')].forEach(c => c.remove());
            
            // Clear and restore zones
            placeableZones = [];
            [...gameBoardZone.querySelectorAll('.placeable-zone')].forEach(z => z.remove());
            if (data.zones) {
                placeableZones = data.zones;
                placeableZones.forEach(zone => renderPlaceableZone(zone));
                // Bump zoneIdCounter beyond existing max numeric id
                const maxIdNum = placeableZones.reduce((m,z)=>{ const n=parseInt((z.id||'').split('_')[1])||0; return n>m?n:m; },0);
                zoneIdCounter = maxIdNum + 1;
            }
            
            if (typeof data.gridSize === 'number') gridSize = data.gridSize;
            if (typeof data.snapToGrid === 'boolean') snapToGrid = data.snapToGrid;
            document.getElementById('snapToggleBtn').classList.toggle('active', snapToGrid);
            data.cards.forEach(entry => {
                playCardToBoard(entry.id);
                const cardEl = [...gameBoardZone.querySelectorAll('.board-card')].slice(-1)[0];
                if (!cardEl) return;
                if (entry.zone) {
                    const zoneEl = document.getElementById(entry.zone);
                    if (zoneEl) {
                        zoneEl.appendChild(cardEl);
                        cardEl.style.position = 'relative';
                        cardEl.style.left = '';
                        cardEl.style.top = '';
                        arrangeZone(zoneEl);
                    }
                } else {
                    cardEl.style.left = entry.left || '0px';
                    cardEl.style.top = entry.top || '0px';
                    cardEl.style.zIndex = entry.z || (++topZIndexCounter).toString();
                }
                cardEl.dataset.rotation = entry.rotation || '0';
                cardEl.dataset.flipped = entry.flipped || '0';
                applyTransform(cardEl);
            });
            updateGridOverlay();
        }

        function autoArrangeBoard() {
            const boardCards = [...gameBoardZone.querySelectorAll('.board-card')].filter(c => !c.closest('.token-zone'));
            if (boardCards.length === 0) { toast('No cards to arrange'); return; }
            const padding = 20;
            const gapX = 25; const gapY = 30;
            const cardW = 280; const cardH = 420; // as per CSS
            const boardW = gameBoardZone.clientWidth;
            const cols = Math.max(1, Math.floor((boardW - padding*2 + gapX) / (cardW + gapX)));
            boardCards.forEach((c,i) => {
                const row = Math.floor(i / cols);
                const col = i % cols;
                c.style.left = (padding + col * (cardW + gapX)) + 'px';
                c.style.top = (padding + row * (cardH + gapY)) + 'px';
                if (snapToGrid) applySnapIfNeeded(c);
            });
            toast('Board arranged');
        }

        /* ===== Deck Management Functions ===== */
        
        function collectCardsToDeck() {
            const boardCards = [...gameBoardZone.querySelectorAll('.board-card')].filter(c => !c.closest('.token-zone') && !c.classList.contains('deck-pile'));
            if (boardCards.length === 0) {
                toast('No cards to collect');
                return;
            }
            
            // Store card data for the deck (add to existing deck, don't replace)
            const newCards = [];
            boardCards.forEach(cardEl => {
                const cardId = cardEl.dataset.cardId;
                const card = cards.find(c => c.id === cardId);
                if (card) {
                    // Store the card data and any board state
                    newCards.push({
                        cardData: card,
                        cardId: cardId,
                        tapped: cardEl.dataset.tapped === '1',
                        flipped: cardEl.dataset.flipped === '1',
                        rotation: cardEl.dataset.rotation || '0'
                    });
                }
                // Remove the card from board
                cardEl.remove();
            });
            
            // Add new cards to existing deck
            boardDeck.push(...newCards);
            
            // Create deck pile visualization
            createDeckPile();
            toast(`Collected ${newCards.length} cards into deck (${boardDeck.length} total)`);
        }
        
        function createDeckPile() {
            // Remove existing deck pile
            const existingDeck = gameBoardZone.querySelector('.deck-pile');
            if (existingDeck) existingDeck.remove();
            
            if (boardDeck.length === 0) {
                isDeckVisible = false;
                return;
            }
            
            // Create deck pile element
            const deckPile = document.createElement('div');
            deckPile.className = 'card-graphic deck-pile';
            deckPile.style.position = 'absolute';
            deckPile.style.left = deckPosition.x + 'px';
            deckPile.style.top = deckPosition.y + 'px';
            deckPile.style.width = '280px';
            deckPile.style.height = '420px';
            deckPile.style.backgroundImage = 'url("src/assets/images/expeditionandgames/TCG Images/cardback.png")';
            deckPile.style.backgroundSize = 'cover';
            deckPile.style.backgroundPosition = 'center';
            deckPile.style.backgroundRepeat = 'no-repeat';
            deckPile.style.border = '2px solid var(--gold)';
            deckPile.style.borderRadius = '8px';
            deckPile.style.display = 'flex';
            deckPile.style.flexDirection = 'column';
            deckPile.style.alignItems = 'center';
            deckPile.style.justifyContent = 'center';
            deckPile.style.cursor = 'pointer';
            deckPile.style.boxShadow = '0 4px 8px rgba(0,0,0,0.3)';
            
            // Add deck content
            deckPile.innerHTML = `
                <div style="position: absolute; bottom: 5px; left: 5px; text-align: left; color: var(--gold); font-weight: bold; background: rgba(0,0,0,1.0); padding: 5px 8px; border-radius: 4px; font-size: 0.9em;">
                    DECK ${boardDeck.length} CARDS
                </div>
            `;
            
            // Add deck interactions
            deckPile.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                showDeckContextMenu(e.clientX, e.clientY);
            });
            
            // Make deck draggable
            makeDeckDraggable(deckPile);
            
            gameBoardZone.appendChild(deckPile);
            isDeckVisible = true;
        }
        
        function makeDeckDraggable(deckEl) {
            let isDragging = false;
            let startX, startY, offsetX, offsetY;
            
            deckEl.addEventListener('pointerdown', (e) => {
                if (e.button === 2) return; // Ignore right clicks
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                const rect = deckEl.getBoundingClientRect();
                const boardRect = gameBoardZone.getBoundingClientRect();
                offsetX = e.clientX - rect.left;
                offsetY = e.clientY - rect.top;
                deckEl.style.cursor = 'grabbing';
                e.preventDefault();
            });
            
            document.addEventListener('pointermove', (e) => {
                if (!isDragging) return;
                const boardRect = gameBoardZone.getBoundingClientRect();
                const newX = e.clientX - boardRect.left - offsetX;
                const newY = e.clientY - boardRect.top - offsetY;
                deckPosition.x = Math.max(0, Math.min(newX, gameBoardZone.clientWidth - 280));
                deckPosition.y = Math.max(0, Math.min(newY, gameBoardZone.clientHeight - 420));
                deckEl.style.left = deckPosition.x + 'px';
                deckEl.style.top = deckPosition.y + 'px';
            });
            
            document.addEventListener('pointerup', () => {
                if (isDragging) {
                    isDragging = false;
                    deckEl.style.cursor = 'pointer';
                }
            });
        }
        
        function shuffleDeck() {
            if (boardDeck.length === 0) {
                toast('No deck to shuffle');
                return;
            }
            
            // Fisher-Yates shuffle algorithm
            for (let i = boardDeck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [boardDeck[i], boardDeck[j]] = [boardDeck[j], boardDeck[i]];
            }
            
            // Add visual feedback
            const deckPile = gameBoardZone.querySelector('.deck-pile');
            if (deckPile) {
                deckPile.style.transform = 'scale(1.1) rotate(5deg)';
                setTimeout(() => {
                    deckPile.style.transform = 'scale(1) rotate(0deg)';
                }, 200);
            }
            
            toast(`Shuffled deck of ${boardDeck.length} cards`);
        }
        
        function dealCards() {
                        if (boardDeck.length === 0) { toast('No cards in deck to deal'); return; }
                        const maxDeal = Math.min(boardDeck.length, 10);
                        showAppPrompt(`How many cards would you like to deal? (1-${maxDeal})`, '1', { max: maxDeal })
                            .then(val => {
                                if (val == null) return; // cancelled
                                if (isNaN(val)) { toast('Invalid number'); return; }
                                const cardsToDeal = Math.max(1, Math.min(parseInt(val), boardDeck.length, 10));
                                performDeal(cardsToDeal);
                            });
                }

                function performDeal(cardsToDeal){
            const dealtCards = boardDeck.splice(0, cardsToDeal);
            
            // Deal cards to the board in a fan pattern
            const startX = deckPosition.x + 350;
            const startY = deckPosition.y;
            
            dealtCards.forEach((deckCard, index) => {
                const cardEl = document.createElement('div');
                cardEl.className = 'card-graphic board-card';
                cardEl.dataset.cardId = deckCard.cardId;
                cardEl.dataset.tapped = deckCard.tapped ? '1' : '0';
                cardEl.dataset.flipped = deckCard.flipped ? '1' : '0';
                cardEl.dataset.rotation = deckCard.rotation;
                cardEl.dataset.x = startX + (index * 30);
                cardEl.dataset.y = startY + (index * 20);
                
                cardEl.style.position = 'absolute';
                cardEl.style.width = '280px';
                cardEl.style.height = '420px';
                cardEl.style.zIndex = (++topZIndexCounter).toString();
                cardEl.textContent = 'Loading...';
                cardEl.classList.add('loading');
                
                // Setup card controls
                setupBoardCardControls(cardEl);
                
                // Make card draggable and enable drop targets
                makeCardDraggable(cardEl);
                enableDropTargets(cardEl);
                
                gameBoardZone.appendChild(cardEl);
                
                // Render the card
                const graphicId = `board_${deckCard.cardId}_0`;
                if (graphicCardCache.has(graphicId)) {
                    const dataUrl = graphicCardCache.get(graphicId);
                    cardEl.classList.remove('loading');
                    cardEl.textContent = '';
                    const img = document.createElement('img');
                    img.src = dataUrl;
                    img.alt = deckCard.cardData.name;
                    img.dataset.originalSrc = dataUrl;
                    cardEl.appendChild(img);
                } else {
                    (async () => {
                        try {
                            const canvas = await renderCardToPNG(deckCard.cardData, 0, {mode: 'board'});
                            const dataUrl = canvas.toDataURL('image/png');
                            graphicCardCache.set(graphicId, dataUrl);
                            cardEl.classList.remove('loading');
                            cardEl.textContent = '';
                            const img = document.createElement('img');
                            img.src = dataUrl;
                            img.alt = deckCard.cardData.name;
                            img.dataset.originalSrc = dataUrl;
                            cardEl.appendChild(img);
                        } catch (e) {
                            console.error('Deal card render failed', e);
                            cardEl.textContent = 'Render fail';
                        }
                    })();
                }
                
                // Apply any saved state
                applyPosition(cardEl);
            });
            
            // Update deck pile
            if (boardDeck.length === 0) {
                const deckPile = gameBoardZone.querySelector('.deck-pile');
                if (deckPile) deckPile.remove();
                isDeckVisible = false;
            } else {
                createDeckPile();
            }
            
            toast(`Dealt ${cardsToDeal} cards from deck`);
        }
        
        function showDeckContextMenu(x, y) {
            const existingMenu = document.querySelector('.deck-context-menu');
            if (existingMenu) existingMenu.remove();
            
            const menu = document.createElement('div');
            menu.className = 'deck-context-menu';
            menu.style.cssText = `
                position: fixed;
                left: ${x}px;
                top: ${y}px;
                background: var(--parchment);
                border: 2px solid var(--gold);
                border-radius: 8px;
                padding: 8px 0;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                z-index: 10000;
                min-width: 150px;
                font-family: serif;
                color: var(--ink);
            `;
            
            const menuItems = [
                { text: '🔀 Shuffle Deck', action: () => shuffleDeck() },
                { text: '📨 Deal Cards', action: () => dealCards() },
                { text: '👁️ Peek Top Card', action: () => peekTopCard() },
                { text: '🔄 Return All to Deck', action: () => returnAllToDeck() },
                { text: '🗑️ Discard Deck', action: () => discardDeck() }
            ];
            
            menuItems.forEach(item => {
                const button = document.createElement('button');
                button.textContent = item.text;
                button.style.cssText = `
                    display: block;
                    width: 100%;
                    padding: 8px 16px;
                    border: none;
                    background: transparent;
                    color: var(--ink);
                    text-align: left;
                    cursor: pointer;
                    font-family: serif;
                    font-size: 14px;
                `;
                button.addEventListener('mouseover', () => button.style.backgroundColor = 'var(--gold-dark)');
                button.addEventListener('mouseout', () => button.style.backgroundColor = 'transparent');
                button.addEventListener('click', () => {
                    item.action();
                    menu.remove();
                });
                menu.appendChild(button);
            });
            
            document.body.appendChild(menu);
            
            // Remove menu when clicking elsewhere
            setTimeout(() => {
                document.addEventListener('click', function removeMenu() {
                    menu.remove();
                    document.removeEventListener('click', removeMenu);
                }, 0);
            });
        }
        
        function peekTopCard() {
            if (boardDeck.length === 0) {
                toast('No cards in deck');
                return;
            }
            
            const topCard = boardDeck[0];
            showCardDetails(topCard.cardData, 0);
            toast('Peeking at top card');
        }
        
        function returnAllToDeck() {
            const boardCards = [...gameBoardZone.querySelectorAll('.board-card')].filter(c => !c.closest('.token-zone') && !c.classList.contains('deck-pile'));
            
            if (boardCards.length === 0) {
                toast('No cards on board to return to deck');
                return;
            }
            
            showAppConfirm(`Return all ${boardCards.length} cards from board to deck?`).then(ok => {
                if(!ok) return;
                boardCards.forEach(cardEl => {
                    const cardId = cardEl.dataset.cardId;
                    const card = cards.find(c => c.id === cardId);
                    if (card) {
                        boardDeck.push({
                            cardData: card,
                            cardId: cardId,
                            tapped: cardEl.dataset.tapped === '1',
                            flipped: cardEl.dataset.flipped === '1',
                            rotation: cardEl.dataset.rotation || '0'
                        });
                        cardEl.remove();
                    }
                });
                createDeckPile();
                toast(`Returned ${boardCards.length} cards to deck`);
            });
        }
        
        function discardDeck() {
            if (boardDeck.length === 0) {
                toast('No cards in deck to discard');
                return;
            }
            
            showAppConfirm(`Discard all ${boardDeck.length} cards from deck?`).then(ok => { if(!ok) return; 
                boardDeck = [];
                const deckPile = gameBoardZone.querySelector('.deck-pile');
                if (deckPile) deckPile.remove();
                isDeckVisible = false;
                toast('Deck discarded');
            });
        }

        function arrangeZone(zoneEl) {
            // Disabled: previously stacked / auto-arranged cards dropped into zones.
            // Intentionally left blank so zones are purely visual and no cards are swallowed/stacked.
            return; 
        }

        /* ===== Life Counter Functions ===== */
        function updateLifeCounter() {
            const counterDisplay = document.getElementById('counterValue');
            if (counterDisplay) {
                counterDisplay.textContent = lifeCounterValue;
            }
        }
        
        function incrementLifeCounter() {
            lifeCounterValue++;
            updateLifeCounter();
            toast(`Life: ${lifeCounterValue}`);
        }
        
        function decrementLifeCounter() {
            lifeCounterValue--;
            updateLifeCounter();
            toast(`Life: ${lifeCounterValue}`);
        }
        
        function resetLifeCounter() {
            lifeCounterValue = 10;
            updateLifeCounter();
            toast('Life reset to 10');
        }

        // Coin flip functionality
        function flipCoin() {
            const coin = document.getElementById('coin');
            const result = document.getElementById('coinResult');
            
            // Add flipping animation
            coin.classList.add('flipping');
            result.textContent = 'Flipping...';
            
            // Random result after animation
            setTimeout(() => {
                const isHeads = Math.random() < 0.5;
                coin.textContent = isHeads ? '🟡' : '🔴';
                result.textContent = isHeads ? 'HEADS' : 'TAILS';
                coin.classList.remove('flipping');
                
                toast(`Coin flip: ${isHeads ? 'HEADS' : 'TAILS'}`);
            }, 1000);
        }

        // Include auto arrange in context menu
        const _origShowContextMenu = showContextMenu;
        showContextMenu = function(x,y){
            _origShowContextMenu(x,y);
            // Append extra options only if menu has actionable items
            const addBtn = (icon,label,handler)=>{
                const b=document.createElement('button');
                b.innerHTML=icon+' '+label; b.onclick=(ev)=>{ev.stopPropagation(); hideContextMenu(); handler();};
                contextMenu.appendChild(b);
            };
            addBtn('🧩','Auto Arrange', autoArrangeBoard);
            addBtn('🗺️','Toggle Grid', toggleGrid);
            addBtn('📤','Export Board', exportBoardJSON);
            addBtn('📥','Import Board', importBoardJSON);
        };

        // High-performance drag (transform) + multi-select group move
        function makeCardDraggable(el){
            if(!el || el._dragBound) return; 
            el._dragBound=true; 
            el.style.touchAction='none';
            el.style.userSelect='none';
            
            el.addEventListener('pointerdown',(e)=>{
                if(e.button!==0) return;
                e.preventDefault();
                e.stopPropagation();
                
                // Set the dragging card for drop zones
                draggingCardEl = el;
                
                if (e.shiftKey) { 
                    toggleSelect(el,true); 
                } else if(!multiSelect.has(el)) { 
                    clearSelection(); 
                    multiSelect.add(el); 
                    refreshSelectionStyles(); 
                }
                
                const group=[...multiSelect]; 
                const startData=group.map(c=>({c,x:parseFloat(c.dataset.x||'0'),y:parseFloat(c.dataset.y||'0')}));
                const sx=e.clientX, sy=e.clientY; 
                let dragging=true;
                let hasMoved=false;
                
                el.classList.add('dragging'); 
                el.style.zIndex=(++topZIndexCounter).toString();
                el.setPointerCapture(e.pointerId);
                
                const move=(ev)=>{ 
                    if(!dragging) return; 
                    const dx=ev.clientX-sx; 
                    const dy=ev.clientY-sy; 
                    if(Math.abs(dx)>3 || Math.abs(dy)>3) hasMoved=true;
                    startData.forEach(p=>{ 
                        p.c.dataset.x=(p.x+dx).toString(); 
                        p.c.dataset.y=(p.y+dy).toString(); 
                        applyPosition(p.c);
                    }); 
                };
                
                const up=(ev)=>{ 
                    dragging=false; 
                    el.classList.remove('dragging'); 
                    el.releasePointerCapture(ev.pointerId);
                    window.removeEventListener('pointermove',move); 
                    window.removeEventListener('pointerup',up);
                    if(snapToGrid) startData.forEach(p=>applySnapIfNeeded(p.c)); 
                    // Zone drop behavior disabled: cards no longer reparent/stack when released over zones.
                    
                    // Clear dragging card reference after a short delay to allow drop events
                    setTimeout(() => { draggingCardEl = null; }, 100);
                };
                
                window.addEventListener('pointermove',move); 
                window.addEventListener('pointerup',up);
            });
        }

        function tapCard(cardEl){ 
            console.log('tapCard called with:', cardEl);
            if(!cardEl) return; 
            const currentTapped = cardEl.dataset.tapped === '1';
            const currentRotation = parseInt(cardEl.dataset.rotation || '0');
            
            if(currentTapped) {
                // Untap: reset to 0 degrees
                cardEl.dataset.tapped = '0';
                cardEl.dataset.rotation = '0';
                console.log('Untapping card');
            } else {
                // Tap: set to 90 degrees
                cardEl.dataset.tapped = '1';
                cardEl.dataset.rotation = '90';
                console.log('Tapping card to 90 degrees');
            }
            applyPosition(cardEl); 
        }

        /* ===== Tokens ===== */
        const tokenPalette = document.getElementById('tokenPalette');
        const tokenPaletteBtn = document.getElementById('tokenPaletteBtn');
        if (tokenPaletteBtn) {
            tokenPaletteBtn.addEventListener('click', (e) => {
                if(!tokenPalette) return;
                const showing = tokenPalette.style.display === 'block';
                if(showing){
                    tokenPalette.style.display = 'none';
                } else {
                    // Position palette just to the right of the vertical toolbar, aligned with this button
                    const btnRect = tokenPaletteBtn.getBoundingClientRect();
                    const boardRect = gameBoardZone.getBoundingClientRect();
                    const offsetX = 10; // gap from toolbar
                    tokenPalette.style.left = (btnRect.right - boardRect.left + offsetX) + 'px';
                    tokenPalette.style.top = (btnRect.top - boardRect.top) + 'px';
                    tokenPalette.style.display = 'block';
                }
            });
        }
        if (tokenPalette) {
            // Build palette buttons if empty (defensive)
            if (tokenPalette.children.length === 0) {
                ['red','blue','green','white','black'].forEach(c => {
                    const b=document.createElement('button'); b.className=c; b.title=c+ ' token'; b.addEventListener('click',()=>spawnToken(c)); tokenPalette.appendChild(b);
                });
            } else {
                tokenPalette.querySelectorAll('button').forEach(b => {
                    b.addEventListener('click', ()=>spawnToken([...b.classList].find(cls=>['red','blue','green','white','black'].includes(cls))));
                });
            }
        }

        function spawnToken(color) {
            const t = document.createElement('div');
            t.className = `board-token token-${color}`;
            t.textContent = '';
            t.style.position = 'absolute';
            t.style.left = (40 + Math.random() * (gameBoardZone.clientWidth - 120)) + 'px';
            t.style.top = (40 + Math.random() * (gameBoardZone.clientHeight - 160)) + 'px';
            t.style.zIndex = (++topZIndexCounter).toString();
            t.dataset.x = t.style.left.replace('px', '');
            t.dataset.y = t.style.top.replace('px', '');
            t.style.left = '0px';
            t.style.top = '0px';
            applyPosition(t);
            makeTokenDraggable(t);
            gameBoardZone.appendChild(t);
        }

        function makeTokenDraggable(t) {
            if(t._tokenDragBound) return;
            t._tokenDragBound = true;
            t.style.touchAction = 'none';
            t.style.userSelect = 'none';
            
            t.addEventListener('pointerdown', (e)=>{
                if(e.button!==0) return;
                e.preventDefault();
                e.stopPropagation();
                
                const startX = e.clientX;
                const startY = e.clientY;
                const origX = parseFloat(t.dataset.x || '0');
                const origY = parseFloat(t.dataset.y || '0');
                let dragging = true;
                
                t.classList.add('dragging');
                t.style.zIndex = (++topZIndexCounter).toString();
                t.setPointerCapture(e.pointerId);
                
                const move = (ev) => {
                    if(!dragging) return;
                    const dx = ev.clientX - startX;
                    const dy = ev.clientY - startY;
                    t.dataset.x = (origX + dx).toString();
                    t.dataset.y = (origY + dy).toString();
                    applyPosition(t);
                };
                
                const up = (ev) => {
                    dragging = false;
                    t.classList.remove('dragging');
                    t.releasePointerCapture(ev.pointerId);
                    window.removeEventListener('pointermove', move);
                    window.removeEventListener('pointerup', up);
                    if (snapToGrid) applySnapIfNeeded(t);
                };
                
                window.addEventListener('pointermove', move);
                window.addEventListener('pointerup', up);
            });
            
            t.addEventListener('contextmenu', (e)=>{ 
                e.preventDefault(); 
                t.remove(); 
            });
            
            t.addEventListener('dblclick', ()=>{ 
                const n = parseInt(t.textContent||'0',10); 
                const next = (n+1)>9?1:n+1; 
                t.textContent = next.toString(); 
            });
        }

        /* ===== UI Collapse Toggle ===== */
        // Add a quick key ("u" or "m") to toggle full board mode, plus button if not present
        function toggleFullUI(){ 
            document.body.classList.toggle('ui-minimized'); 
            const btn = document.getElementById('toggleUIBtn');
            if(btn) {
                btn.textContent = document.body.classList.contains('ui-minimized') ? 'Show Cards' : 'Hide Cards';
            }
        }
        document.addEventListener('keydown',(e)=>{ 
            if((e.key==='u' || e.key==='m') && !e.target.matches('input,textarea')) { 
                toggleFullUI(); 
            }
        });
        // If we have a toolbar, inject a button dynamically (safer than editing HTML again)
        (function ensureUICollapseButton(){
            const toolbar = document.querySelector('.board-toolbar');
            if(!toolbar) return;
            const existingBtn = toolbar.querySelector('#toggleUIBtn');
            if(existingBtn) {
                existingBtn.addEventListener('click', toggleFullUI);
                existingBtn.textContent = 'Hide Cards';
                existingBtn.title = 'Hide/Show Card List UI (U or M)';
            }
        })();

        document.getElementById('snapToggleBtn').addEventListener('click', toggleSnap);
        document.getElementById('saveBoardBtn').addEventListener('click', saveBoardState);
        document.getElementById('loadBoardBtn').addEventListener('click', loadBoardState);
        document.getElementById('clearBoardBtn').addEventListener('click', clearBoard);
        document.getElementById('stackBtn').addEventListener('click', stackSelected);
        document.getElementById('unstackBtn').addEventListener('click', unstackSelected);
    document.getElementById('gridToggleBtn').addEventListener('click', toggleGrid);
    document.getElementById('exportBoardBtn').addEventListener('click', exportBoardJSON);
    document.getElementById('importBoardBtn').addEventListener('click', importBoardJSON);
    document.getElementById('autoArrangeBtn').addEventListener('click', autoArrangeBoard);
    document.getElementById('createZoneBtn').addEventListener('click', () => {
        const x = 300 + (placeableZones.length * 50); // Offset new zones
        const y = 200 + (placeableZones.length * 30);
        createPlaceableZone(x, y, `Zone ${placeableZones.length + 1}`);
    });
    
    // Deck management event listeners
    document.getElementById('collectToDeckBtn').addEventListener('click', collectCardsToDeck);
    document.getElementById('shuffleDeckBtn').addEventListener('click', shuffleDeck);
    document.getElementById('dealCardsBtn').addEventListener('click', dealCards);
    
    // Life counter event listeners
    document.getElementById('counterPlus').addEventListener('click', incrementLifeCounter);
    document.getElementById('counterMinus').addEventListener('click', decrementLifeCounter);
    document.getElementById('counterValue').addEventListener('dblclick', resetLifeCounter);
        
        function toggleDeckView() {
            deckVisible = !deckVisible;
            deckView.style.display = deckVisible ? 'block' : 'none';
            toggleDeckBtn.textContent = deckVisible ? '🙈 Hide Deck' : '👁️ Show Deck';
            if (deckVisible) {
                updateDeckDisplay();
            }
        }
        
        function saveDeck() {
            if (playerDeck.length === 0) { showAppAlert('No cards in deck to save!'); return; }
            
            const deckData = JSON.stringify(playerDeck, null, 2);
            const dataBlob = new Blob([deckData], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'diaper-school-deck.json';
            link.click();
            URL.revokeObjectURL(url);
        }
        
        function loadDeck() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = function(event) {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        try {
                            const importedDeck = JSON.parse(e.target.result);
                            if (Array.isArray(importedDeck)) {
                                playerDeck = importedDeck;
                                updateDeckStats();
                                updateDeckDisplay();
                                updateAddButtons();
                                showAppAlert('Deck loaded successfully!');
                            }
                        } catch (error) {
                            showAppAlert('Error reading deck file: ' + error.message);
                        }
                    };
                    reader.readAsText(file);
                }
            };
            input.click();
        }
        
    function loadStarterDeck1() {
            // Academy Tempo starter deck - modified with 20 boosters
            const starterDeck = [
                // Creatures (18) - Reduced from 24
                'student_001', 'student_001', // Kittenfolk Pouncer ×2 (reduced from 3)
                'student_003', 'student_003', // Pupperling Watchkin ×2
                'student_004', // Bunbunkin Bigpaw ×1 (reduced from 2)
                'student_037', 'student_037', // Umbral Mystic ×2
                'student_038', // Pupperling Archer ×1 (reduced from 2)
                'student_040', 'student_040', // Waddlehoof Student ×2
                'student_053', 'student_053', // Academy Freshman ×2 (reduced from 3)
                'student_054', 'student_054', // Senior Auditor ×2
                'monster_031', // Forgotten Rattle ×1
                'monster_026', // Lost Plushie ×1 (reduced from 2)
                'monster_010', // Nailbearer ×1
                'monster_032', // Sentient Crib ×1
                
                // Spells (11) - Same as before
                'spell_012', 'spell_012', 'spell_012', // Spank! ×3
                'spell_002', 'spell_002', // Diapering ×2
                'spell_003', // Babybrain ×1
                'spell_014', // Parental Power ×1
                'spell_015', // Plushie Form ×1
                'spell_016', // Create Changing Supplies ×1
                'spell_021', // Potty Portal ×1
                'spell_017', // Mass Pacification ×1
                
                // Items/Artifacts (6) - Same as before
                'item_008', 'item_008', // Diapering for Dummies ×2
                'item_010', // Bottle of Endless Milk ×1
                'item_009', // Fuzzyfeet Slipper-Socks ×1
                'artifact_014', // Dweomer Diaper ×1
                'artifact_011', // Nursery Domain's Embrace ×1
                
                // Boosters (20) - Increased from 14
                'booster_001', 'booster_001', 'booster_001', 'booster_001', 'booster_001', // UniGuard Basic White ×5 (increased from 4)
                'booster_006', 'booster_006', 'booster_006', 'booster_006', // UltraDry Max Absorbency ×4 (increased from 3)
                'booster_012', 'booster_012', 'booster_012', 'booster_012', // Basic Universal Booster ×4 (increased from 3)
                'booster_013', 'booster_013', 'booster_013', // Advanced Universal Booster ×3 (increased from 2)
                'booster_011', 'booster_011', 'booster_011', // Ultimate Booster ×3 (increased from 2)
                'booster_002' // Comfort-Fit Pull-Ups ×1 (new addition)
            ];
            
            // Clear current deck
            playerDeck = [];
            
            // Add each card to the deck
            let foundCards = 0;
            let missingCards = [];
            
            starterDeck.forEach(cardId => {
                const card = cards.find(c => c.id === cardId);
                if (card) {
                    playerDeck.push({...card, deckId: generateId()});
                    foundCards++;
                } else {
                    missingCards.push(cardId);
                }
            });
            
            // Update the display
            updateDeckStats();
            updateDeckDisplay();
            updateAddButtons();
            
            // Show result message
            if (missingCards.length > 0) {
                showAppAlert(`Academy Tempo deck loaded: ${foundCards}/55 cards found.\nMissing cards: ${missingCards.join(', ')}`);
            } else {
                showAppAlert(`Academy Tempo starter deck loaded successfully! All 55 cards added (20 boosters included).`);
            }
        }

        function loadDarklingDeck() {
            const deckList = [
                // Creatures (17)
                'monster_001','monster_001','monster_001', // Darkling-Lurker ×3
                'monster_002', // Darkling-Slurper ×1
                'monster_003', // Darkforme Overwatch ×1
                'monster_004','monster_004', // Darkforme Enforcer ×2
                'monster_016','monster_016', // Darkling-Ghostiby ×2
                'monster_017', // Shadow Babysitter ×1
                'monster_018', // Darkforme-Hungore ×1
                'monster_047','monster_047', // Darkling Angler-Lurk ×2
                'monster_048','monster_048', // Darkling Rill-Skitter ×2
                'monster_013', // Darkforged Remnant (Lash) ×1
                'student_103', // Helen, Darkling Student ×1
                // Spells (11)
                'spell_027','spell_027', // Pack Tactics ×2
                'spell_028','spell_028', // Slurp Drain ×2
                'spell_029','spell_029', // Shadowmist Jaunt ×2
                'spell_033', // Ink Spray ×1
                'spell_034', // Pants-Crapping Terror ×1
                'spell_011', // Uncrinkling Catastrophe ×1
                'spell_021', // Potty Portal ×1
                'spell_010', // Hymn of the Lullaby ×1
                // Items/Artifacts (6)
                'item_015','item_015', // Shadow Essence ×2
                'item_016','item_016', // Darkling Residue ×2
                'item_018', // Nightmare Mitts ×1
                'item_022', // Ink Sac ×1
                // Boosters (21)
                'booster_008','booster_008','booster_008','booster_008','booster_008','booster_008', // Shadow Booster ×6
                'booster_009','booster_009','booster_009','booster_009','booster_009', // Advanced Shadow Booster ×5
                'booster_010','booster_010', // Void Booster ×2
                'booster_001','booster_001','booster_001','booster_001', // UniGuard Basic White ×4
                'booster_012','booster_012','booster_012', // Basic Universal Booster ×3
                'booster_013' // Advanced Universal Booster ×1
            ];

            playerDeck = [];
            let found = 0; let missing = [];
            deckList.forEach(id => { const c = cards.find(x=>x.id===id); if(c){ playerDeck.push({...c, deckId: generateId()}); found++; } else missing.push(id); });
            updateDeckStats(); updateDeckDisplay(); updateAddButtons();
            if(missing.length){ showAppAlert(`Darkling Control deck loaded: ${found}/55 cards found. Missing: ${missing.join(', ')}`); }
            else { showAppAlert('🌑 Darkling Control deck loaded successfully (55 cards, 21 Boosters).'); }
        }

        function loadElementalFluxDeck() {
            const deckList = [
                // Creatures (17)
                'student_028','student_028','student_028', // Emberclaw Flame Dancer ×3
                'student_029','student_029', // Emberclaw Fire Sage ×2
                'student_008','student_008', // Emberclaw Striker ×2
                'student_036', // Tyrannobrat ×1
                'student_050', // T-Wrecks Alpha ×1
                'student_035','student_035', // Pterosaur Skyseeker ×2
                'student_044', // Veloci-Rascal Scout ×1
                'student_060', // Pterodac-tot Explorer ×1
                'student_101', // Taisiat, Time-Skipper ×1
                'monster_044', // Bottle Elemental ×1
                'monster_010', // Nailbearer ×1
                'student_001', // Kittenfolk Pouncer ×1
                // Spells (11)
                'spell_018','spell_018','spell_018', // Diaper Detonation ×3
                'spell_013','spell_013', // Smelly Smite ×2
                'spell_020','spell_020', // Magic Messile ×2
                'spell_010', // Hymn of the Lullaby ×1
                'spell_021', // Potty Portal ×1
                'spell_015', // Plushie Form ×1
                'spell_008', // Little Miracle ×1
                // Items/Artifacts (5)
                'artifact_014', // Dweomer Diaper ×1
                'item_009', // Fuzzyfeet Slipper-Socks ×1
                'item_010', // Bottle of Endless Milk ×1
                'artifact_017', // Padding Paddle ×1
                'item_002', // Gluttonberries ×1
                // Boosters (22)
                'booster_004','booster_004','booster_004','booster_004','booster_004','booster_004', // DinoMite Volcano Valley ×6
                'booster_020','booster_020','booster_020', // Reinforced Pyro Booster ×3
                'booster_003','booster_003','booster_003','booster_003','booster_003', // HolidayCheer SnowflakeSnuggle ×5
                'booster_021','booster_021', // Deep Freeze Cryo Booster ×2
                'booster_001','booster_001','booster_001', // UniGuard Basic White ×3
                'booster_012','booster_012','booster_012' // Basic Universal Booster ×3
            ];

            playerDeck = [];
            let found = 0; let missing = [];
            deckList.forEach(id => { const c = cards.find(x=>x.id===id); if(c){ playerDeck.push({...c, deckId: generateId()}); found++; } else missing.push(id); });
            updateDeckStats(); updateDeckDisplay(); updateAddButtons();
            if(missing.length){ showAppAlert(`Elemental Flux deck loaded: ${found}/55 cards found. Missing: ${missing.join(', ')}`); }
            else { showAppAlert('🔥❄️ Elemental Flux deck loaded successfully (55 cards, 22 Boosters).'); }
        }
        
        async function exportDeckAsPNG() {
            if (playerDeck.length !== 55) { showAppAlert('Deck must have exactly 55 cards to export as PNG!'); return; }
            
            // Show progress modal
            const progressModal = document.createElement('div');
            progressModal.className = 'modal active';
            progressModal.innerHTML = `
                <div class="modal-content" style="max-width: 400px;">
                    <div class="modal-header">
                        <h2 class="modal-title">Exporting Deck as PNG...</h2>
                    </div>
                    <div class="modal-body" style="text-align: center;">
                        <div class="spinner"></div>
                        <p id="exportProgress">Preparing cards... (0/55)</p>
                    </div>
                </div>
            `;
            document.body.appendChild(progressModal);
            
            try {
                const zip = new JSZip();
                
                for (let i = 0; i < playerDeck.length; i++) {
                    const card = playerDeck[i];
                    document.getElementById('exportProgress').textContent = `Rendering card ${i + 1}/55: ${card.name}`;
                    
                    const canvas = await renderCardToPNG(card, i);
                    
                    // Convert canvas to blob and add to zip
                    const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png', 1.0));
                    const cardNumber = String(i + 1).padStart(2, '0');
                    const fileName = `${cardNumber}_${card.name.replace(/[^a-zA-Z0-9]/g, '_')}.png`;
                    zip.file(fileName, blob);
                    
                    // Small delay to prevent browser freezing
                    await new Promise(resolve => setTimeout(resolve, 10));
                }
                
                // Generate and download zip file
                document.getElementById('exportProgress').textContent = 'Creating download file...';
                const zipBlob = await zip.generateAsync({type: "blob"});
                const url = URL.createObjectURL(zipBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = 'diaper-school-deck-cards.zip';
                link.click();
                URL.revokeObjectURL(url);
                
                document.body.removeChild(progressModal);
                showAppAlert('Deck exported successfully! Check your downloads folder.');
                
            } catch (error) {
                document.body.removeChild(progressModal);
                showAppAlert('Error exporting deck: ' + error.message);
                console.error('Export error:', error);
            }
        }
        
        async function printSingleCard() {
            if (!currentModalCard) { showAppAlert('No card selected to print!'); return; }
            
            try {
                // Show a simple loading indicator
                printCardBtn.textContent = '🔄 Rendering...';
                printCardBtn.disabled = true;
                
                const canvas = await renderCardToPNG(currentModalCard, currentModalCardIndex);
                
                // Convert canvas to blob and download
                const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png', 1.0));
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `${currentModalCard.name.replace(/[^a-zA-Z0-9]/g, '_')}.png`;
                link.click();
                URL.revokeObjectURL(url);
                
                // Reset button
                printCardBtn.textContent = '🖼️ Print as PNG';
                printCardBtn.disabled = false;
                
                // Show success message
                const successMsg = document.createElement('div');
                successMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #4CAF50; color: white; padding: 15px; border-radius: 5px; z-index: 10000; font-weight: bold;';
                successMsg.textContent = '✅ Card exported successfully!';
                document.body.appendChild(successMsg);
                setTimeout(() => document.body.removeChild(successMsg), 3000);
                
            } catch (error) {
                printCardBtn.textContent = '🖼️ Print as PNG';
                printCardBtn.disabled = false;
                showAppAlert('Error printing card: ' + error.message);
                console.error('Print error:', error);
            }
        }
        
        // Helper function to load image as data URL to avoid taint issues
        async function loadImageAsDataURL(imageUrl) {
            try {
                // If it's already a data URL, return it as is
                if (imageUrl.startsWith('data:')) {
                    return imageUrl;
                }
                
                // For local files, try to fetch and convert to data URL
                if (!imageUrl.startsWith('http')) {
                    const response = await fetch(imageUrl);
                    const blob = await response.blob();
                    return new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = () => resolve(reader.result);
                        reader.onerror = reject;
                        reader.readAsDataURL(blob);
                    });
                }
                
                // For external URLs, we'll have to use a different approach
                // Try to load directly first
                return imageUrl;
            } catch (e) {
                console.log('Failed to convert image to data URL:', e);
                return imageUrl; // Fall back to original URL
            }
        }

        async function renderCardToPNG(card, cardIndex = 0, options = {}) {
            const mode = options.mode || 'list';
            // Create a temporary canvas for this card
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // Set card dimensions to match the UI cards proportionally (scale up for high-res)
            const scale = 3; // Scale factor for high resolution
            canvas.width = 280 * scale;   // Match UI card width
            canvas.height = 420 * scale;  // Match UI card height
            
            // Scale the context for high-resolution drawing
            ctx.scale(scale, scale);
            
            // Check if this is a deluxe full-art card
            const variants = getArtVariants(card);
            const uniqueId = `${card.id}_${cardIndex}`;
            const currentIndex = currentArtIndex[uniqueId] || 0;
            const currentImageUrl = variants[currentIndex] || card.image_url || card.image_placeholder;
            const isDeluxeMode = card.is_full_card && card.deluxe_art_url;
            
            // First, draw the base background (always needed)
            ctx.fillStyle = '#2C2614'; // --parchment
            ctx.fillRect(0, 0, 280, 420);
            
            // Draw deluxe full-art background if in deluxe mode
            if (isDeluxeMode) {
                try {
                    const deluxeDataUrl = await loadImageAsDataURL(card.deluxe_art_url);
                    const deluxeImg = new Image();
                    await new Promise((resolve, reject) => {
                        deluxeImg.onload = resolve;
                        deluxeImg.onerror = reject;
                        deluxeImg.src = deluxeDataUrl;
                    });
                    
                    // Draw the full deluxe art as background covering the entire card
                    // This breaks out of the normal image frame and fills the whole card
                    ctx.drawImage(deluxeImg, 0, 0, 280, 420);
                    
                    // Add a very subtle overlay to ensure text readability without obscuring the art
                    ctx.fillStyle = 'rgba(44, 38, 20, 0.08)'; // Very light parchment overlay
                    ctx.fillRect(0, 0, 280, 420);
                } catch (e) {
                    console.log('Deluxe art failed to load, falling back to normal mode:', e);
                    // Fall back already handled by base background above
                }
            }
            
            // Draw card border (matching .card border)
            ctx.strokeStyle = '#97740a'; // --gold-dark
            ctx.lineWidth = 3;
            ctx.strokeRect(1.5, 1.5, 277, 417);
            
            // Draw card header background (with transparency for deluxe mode)
            const headerGradient = ctx.createLinearGradient(0, 0, 0, 44);
            if (isDeluxeMode) {
                // Semi-transparent header for deluxe mode to show art underneath
                headerGradient.addColorStop(0, 'rgba(151, 116, 10, 0.85)'); // --gold-dark with transparency
                headerGradient.addColorStop(1, 'rgba(218, 172, 23, 0.85)'); // --gold with transparency
            } else {
                headerGradient.addColorStop(0, '#97740a'); // --gold-dark
                headerGradient.addColorStop(1, '#daac17'); // --gold
            }
            ctx.fillStyle = headerGradient;
            ctx.fillRect(3, 3, 274, 44);
            
            // Add extra border for deluxe mode text readability
            if (isDeluxeMode) {
                ctx.strokeStyle = '#5a4706'; // Darker gold border
                ctx.lineWidth = 1;
                ctx.strokeRect(3, 3, 274, 44);
            }
            
            // Draw header border
            ctx.strokeStyle = '#97740a';
            ctx.lineWidth = 1;
            ctx.strokeRect(3, 47, 274, 1);
            
            // Draw card name with enhanced styling for deluxe mode
            ctx.fillStyle = '#2C2614'; // --parchment
            ctx.font = 'bold 16px serif';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            
            if (isDeluxeMode) {
                // Add text shadow and glow for deluxe mode
                ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;
                ctx.shadowBlur = 4;
                
                // Draw glow effect
                ctx.strokeStyle = 'rgba(218, 172, 23, 0.6)'; // Gold glow
                ctx.lineWidth = 3;
                ctx.strokeText(card.name, 12, 25);
            }
            
            ctx.fillText(card.name, 12, 25);
            
            // Reset shadow
            ctx.shadowColor = 'transparent';
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            ctx.shadowBlur = 0;
            
            // Draw cost symbols with proper positioning based on count using energy icons
            if (card.cost && card.cost !== 'Free') {
                const energyMap = {
                    'Universal': { 
                        icon: 'src/assets/images/expeditionandgames/TCG Images/universalergy.webp',
                        textColor: '#000000',
                        strokeColor: '#ffffff',
                        useStroke: true
                    },
                    'Hydronergy': { 
                        icon: 'src/assets/images/expeditionandgames/TCG Images/Hydrergy.webp',
                        textColor: '#1e3a8a',
                        strokeColor: '#1e3a8a',
                        useStroke: false
                    }, 
                    'Hydro': { 
                        icon: 'src/assets/images/expeditionandgames/TCG Images/Hydrergy.webp',
                        textColor: '#1e3a8a',
                        strokeColor: '#1e3a8a',
                        useStroke: false
                    }, 
                    'Pyronergy': { 
                        icon: 'src/assets/images/expeditionandgames/TCG Images/Pyrergy.webp',
                        textColor: '#ff8c00',
                        strokeColor: '#ffd700',
                        useStroke: true
                    },
                    'Pyro': { 
                        icon: 'src/assets/images/expeditionandgames/TCG Images/Pyrergy.webp',
                        textColor: '#ff8c00',
                        strokeColor: '#ffd700',
                        useStroke: true
                    },
                    'Cryonergy': { 
                        icon: 'src/assets/images/expeditionandgames/TCG Images/cryergy.webp',
                        textColor: '#1e3a8a',
                        strokeColor: '#000000',
                        useStroke: true
                    },
                    'Cryo': { 
                        icon: 'src/assets/images/expeditionandgames/TCG Images/cryergy.webp',
                        textColor: '#1e3a8a',
                        strokeColor: '#000000',
                        useStroke: true
                    },
                    'Geonergy': { 
                        icon: 'src/assets/images/expeditionandgames/TCG Images/geoergy.webp',
                        textColor: '#ffd700',
                        strokeColor: '#b8860b',
                        useStroke: true
                    },
                    'Geo': { 
                        icon: 'src/assets/images/expeditionandgames/TCG Images/geoergy.webp',
                        textColor: '#ffd700',
                        strokeColor: '#b8860b',
                        useStroke: true
                    },
                    'Shadergy': { 
                        icon: 'src/assets/images/expeditionandgames/TCG Images/shadergy.webp',
                        textColor: '#ffffff',
                        strokeColor: '#000000',
                        useStroke: true
                    },
                    'Shadow': { 
                        icon: 'src/assets/images/expeditionandgames/TCG Images/shadergy.webp',
                        textColor: '#ffffff',
                        strokeColor: '#000000',
                        useStroke: true
                    }
                };
                
                // Set better image rendering quality for energy icons
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';
                
                const parts = card.cost.split(',');
                const costY = 25; // Centered in 44px header height
                
                // Different sizing based on number of symbols - increased to match CSS scaling
                let iconSize, fontSize, gap;
                if (parts.length === 1) {
                    iconSize = 38; fontSize = 20; gap = 0; // Matches CSS .cost-single
                } else if (parts.length === 2) {
                    iconSize = 28; fontSize = 15; gap = 2; // Matches CSS .cost-double  
                } else {
                    // 3+ costs - use better triangular arrangement that fits within bounds
                    iconSize = 22; fontSize = 12; // Slightly larger for better visibility
                    
                    // Better triangular positioning for 3+ symbols - ensure they fit
                    const positions = [
                        { x: 250, y: 15 },   // top - better centered
                        { x: 238, y: 35 },   // bottom left - more spacing
                        { x: 262, y: 35 },   // bottom right - more spacing  
                        { x: 250, y: 42 }    // bottom center for 4th if needed
                    ];
                    
                    // Process each energy cost with icons
                    for (let index = 0; index < parts.length && index < positions.length; index++) {
                        const part = parts[index];
                        const trimmed = part.trim();
                        const match = trimmed.match(/(\d+)\s*(.+)/);
                        if (match) {
                            const amount = parseInt(match[1]);
                            const energyType = match[2].trim();
                            const energyInfo = energyMap[energyType];
                            
                            if (energyInfo) {
                                try {
                                    const iconDataUrl = await loadImageAsDataURL(energyInfo.icon);
                                    const iconImg = new Image();
                                    await new Promise((resolve, reject) => {
                                        iconImg.onload = resolve;
                                        iconImg.onerror = reject;
                                        iconImg.src = iconDataUrl;
                                    });
                                    
                                    const pos = positions[index];
                                    
                                    // Draw energy icon
                                    ctx.drawImage(iconImg, pos.x - iconSize/2, pos.y - iconSize/2, iconSize, iconSize);
                                    
                                    // Draw number centered on icon
                                    ctx.font = `bold ${fontSize}px serif`;
                                    ctx.textAlign = 'center';
                                    ctx.textBaseline = 'middle';
                                    
                                    if (energyInfo.useStroke) {
                                        ctx.strokeStyle = energyInfo.strokeColor;
                                        ctx.lineWidth = 2;
                                        ctx.strokeText(amount.toString(), pos.x, pos.y);
                                    }
                                    
                                    ctx.fillStyle = energyInfo.textColor;
                                    ctx.fillText(amount.toString(), pos.x, pos.y);
                                } catch (e) {
                                    console.log(`Failed to load energy icon for ${energyType}, using fallback`);
                                    // Fallback to old colored box system
                                    ctx.fillStyle = '#d1d5db';
                                    ctx.fillRect(pos.x - iconSize/2, pos.y - iconSize/2, iconSize, iconSize);
                                    ctx.fillStyle = '#374151';
                                    ctx.font = `bold ${fontSize}px serif`;
                                    ctx.textAlign = 'center';
                                    ctx.textBaseline = 'middle';
                                    ctx.fillText(amount.toString(), pos.x, pos.y);
                                }
                            }
                        }
                    }
                }
                
                // Only render linear layout for 1-2 cost cards
                if (parts.length <= 2) {
                    const totalWidth = (parts.length * iconSize) + ((parts.length - 1) * gap);
                    let startX = 280 - totalWidth - 8;
                    
                    // Process each energy cost with icons
                    for (let index = 0; index < parts.length; index++) {
                        const part = parts[index];
                        const trimmed = part.trim();
                        const match = trimmed.match(/(\d+)\s*(.+)/);
                        if (match) {
                            const amount = parseInt(match[1]);
                            const energyType = match[2].trim();
                            const energyInfo = energyMap[energyType];
                            
                            if (energyInfo) {
                                try {
                                    const iconDataUrl = await loadImageAsDataURL(energyInfo.icon);
                                    const iconImg = new Image();
                                    await new Promise((resolve, reject) => {
                                        iconImg.onload = resolve;
                                        iconImg.onerror = reject;
                                        iconImg.src = iconDataUrl;
                                    });
                                    
                                    const iconX = startX + (index * (iconSize + gap));
                                    const iconY = costY - iconSize/2;
                                    
                                    // Draw energy icon
                                    ctx.drawImage(iconImg, iconX, iconY, iconSize, iconSize);
                                    
                                    // Draw number centered on icon
                                    ctx.font = `bold ${fontSize}px serif`;
                                    ctx.textAlign = 'center';
                                    ctx.textBaseline = 'middle';
                                    
                                    if (energyInfo.useStroke) {
                                        ctx.strokeStyle = energyInfo.strokeColor;
                                        ctx.lineWidth = 2;
                                        ctx.strokeText(amount.toString(), iconX + iconSize/2, costY);
                                    }
                                    
                                    ctx.fillStyle = energyInfo.textColor;
                                    ctx.fillText(amount.toString(), iconX + iconSize/2, costY);
                                } catch (e) {
                                    console.log(`Failed to load energy icon for ${energyType}, using fallback`);
                                    // Fallback to old colored box system
                                    const iconX = startX + (index * (iconSize + gap));
                                    ctx.fillStyle = '#d1d5db';
                                    ctx.fillRect(iconX, costY - iconSize/2, iconSize, iconSize);
                                    ctx.fillStyle = '#374151';
                                    ctx.font = `bold ${fontSize}px serif`;
                                    ctx.textAlign = 'center';
                                    ctx.textBaseline = 'middle';
                                    ctx.fillText(amount.toString(), iconX + iconSize/2, costY);
                                }
                            }
                        }
                    }
                }
                
                // Reset image smoothing to default
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'medium';
            }
            
            // Draw image container area (matching .card-image-container)
            const imageY = 48;
            const imageHeight = 220;
            
            // Only draw image background in normal mode, skip in deluxe mode to show full art
            if (!isDeluxeMode) {
                ctx.fillStyle = '#1E1C12'; // --parchment-dark (image background)
                ctx.fillRect(3, imageY, 274, imageHeight);
            }
            
            // Draw image border
            ctx.strokeStyle = '#97740a';
            ctx.lineWidth = 1;
            ctx.strokeRect(3, imageY + imageHeight, 274, 1);
            
            // Draw card image if available - using currently selected art variant
            // Skip drawing the normal image in deluxe mode since the full art already covers the card
            if (!isDeluxeMode && (card.image_url || card.image_placeholder)) {
                try {
                    // Get the current art variant for this card
                    const variants = getArtVariants(card);
                    const uniqueId = `${card.id}_${cardIndex}`;
                    const currentIndex = currentArtIndex[uniqueId] || 0;
                    const imageUrl = variants[currentIndex] || card.image_url || card.image_placeholder;
                    
                    const dataUrl = await loadImageAsDataURL(imageUrl);
                    
                    const img = new Image();
                    await new Promise((resolve, reject) => {
                        img.onload = () => {
                            console.log('Image loaded successfully as data URL:', imageUrl);
                            resolve();
                        };
                        img.onerror = (e) => {
                            console.log('Image failed to load even as data URL:', imageUrl, e);
                            reject(e);
                        };
                        img.src = dataUrl; // Use the data URL instead of original URL
                    });
                    
                    // Calculate image positioning to fit within container (object-fit: contain)
                    const imgArea = {
                        x: 3,
                        y: imageY,
                        width: 274,
                        height: imageHeight
                    };
                    
                    const imgAspect = img.width / img.height;
                    const areaAspect = imgArea.width / imgArea.height;
                    
                    let drawWidth, drawHeight, drawX, drawY;
                    if (imgAspect > areaAspect) {
                        drawWidth = imgArea.width;
                        drawHeight = imgArea.width / imgAspect;
                        drawX = imgArea.x;
                        drawY = imgArea.y + (imgArea.height - drawHeight) / 2;
                    } else {
                        drawHeight = imgArea.height;
                        drawWidth = imgArea.height * imgAspect;
                        drawX = imgArea.x + (imgArea.width - drawWidth) / 2;
                        drawY = imgArea.y;
                    }
                    
                    console.log('Drawing image at:', drawX, drawY, drawWidth, drawHeight);
                    ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
                } catch (e) {
                    console.log('Image loading failed completely, using placeholder for:', card.name, e);
                    // Only use placeholder if image completely fails
                    ctx.fillStyle = '#8f770d'; // --ink2
                    ctx.font = '16px serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('🎴 ' + card.name, 140, imageY + imageHeight/2);
                }
            } else if (!isDeluxeMode) {
                // Only show placeholder text if not in deluxe mode
                ctx.fillStyle = '#8f770d'; // --ink2
                ctx.font = '16px serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('🎴 ' + card.name, 140, imageY + imageHeight/2);
            }
            
            // Draw HP/ATK stat icons if available (using custom images)
            const hasStats = (card.hp !== undefined && card.hp !== null) || (card.atk !== undefined && card.atk !== null);
            if (hasStats) {
                // Set better image rendering quality
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';
                
                const statsY = imageY + 8;
                
                if (card.hp !== undefined && card.hp !== null) {
                    // Load and draw HP shield icon using data URL
                    try {
                        const hpIconUrl = 'src/assets/images/expeditionandgames/TCG Images/HPshield.webp';
                        const hpDataUrl = await loadImageAsDataURL(hpIconUrl);
                        
                        const hpImg = new Image();
                        await new Promise((resolve, reject) => {
                            hpImg.onload = resolve;
                            hpImg.onerror = reject;
                            hpImg.src = hpDataUrl;
                        });
                        
                        // Draw HP shield at higher resolution for better quality
                        const hpSize = 40; // Increased from 32 for better quality
                        const hpX = 24 - hpSize/2; // Center on original position
                        const hpY = statsY + 16 - hpSize/2;
                        ctx.drawImage(hpImg, hpX, hpY, hpSize, hpSize);
                        
                        // HP text (centered on shield) - dark blue for better visibility
                        ctx.fillStyle = '#061A54'; // Dark blue color
                        ctx.font = 'bold 16px serif'; // Increased font size
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 2;
                        ctx.strokeText(card.hp.toString(), 24, statsY + 16);
                        ctx.fillText(card.hp.toString(), 24, statsY + 16);
                    } catch (e) {
                        console.log('HP shield image failed to load, using fallback');
                        // Fallback to circle if image fails
                        ctx.fillStyle = '#e74c3c';
                        ctx.strokeStyle = 'rgba(255,255,255,0.4)';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.arc(24, statsY + 16, 20, 0, 2 * Math.PI); // Slightly larger
                        ctx.fill();
                        ctx.stroke();
                        ctx.fillStyle = 'white';
                        ctx.font = 'bold 14px serif';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(card.hp.toString(), 24, statsY + 16);
                    }
                }
                
                if (card.atk !== undefined && card.atk !== null) {
                    // Use atkicon.png for both list and board modes
                    const atkBase = 'atkicon.png';
                    const possiblePaths = [
                        `src/assets/images/expeditionandgames/TCG Images/${atkBase}`,
                        `./src/assets/images/expeditionandgames/TCG Images/${atkBase}`,
                        `./${atkBase}`,
                        atkBase
                    ];
                    
                    let atkImg = null;
                    for (const path of possiblePaths) {
                        try {
                            atkImg = new Image();
                            atkImg.crossOrigin = 'anonymous';
                            
                            await new Promise((resolve, reject) => {
                                atkImg.onload = () => {
                                    console.log(`ATK icon loaded successfully from: ${path}`);
                                    resolve();
                                };
                                atkImg.onerror = () => {
                                    console.log(`Failed to load ATK icon from: ${path}`);
                                    reject();
                                };
                                atkImg.src = path;
                            });
                            
                            // If we get here, the image loaded successfully
                            break;
                        } catch (e) {
                            console.log(`Path ${path} failed, trying next...`);
                            atkImg = null;
                            continue;
                        }
                    }
                    
                    if (atkImg && atkImg.complete && atkImg.naturalWidth > 0) {
                        // Draw ATK icon at higher resolution for better quality
                        const atkSize = 40; // Increased from 32 for better quality
                        const atkX = 256 - atkSize/2; // Center better
                        const atkY = statsY + 16 - atkSize/2;
                        
                        ctx.drawImage(atkImg, atkX, atkY, atkSize, atkSize);
                        
                        // Draw ATK text with better positioning
                        ctx.fillStyle = '#000000';
                        ctx.font = 'bold 16px serif'; // Increased font size
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 2;
                        
                        // Position text slightly higher in the icon for better alignment
                        ctx.strokeText(card.atk.toString(), atkX + atkSize/2, atkY + atkSize/2 + 1);
                        ctx.fillText(card.atk.toString(), atkX + atkSize/2, atkY + atkSize/2 + 1);
                    } else {
                        console.error('ALL ATK ICON PATHS FAILED - CANNOT RENDER CARD');
                        throw new Error('Failed to load atkicon.png from any path');
                    }
                }
                
                // Reset image smoothing to default
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'medium';
            }
            
            // Draw subtype bottom section if available (matching .card-subtype-bottom)
            let currentY = imageY + imageHeight + 2;
            let subtypeText = '';
            
            if (card.type?.includes('Student')) subtypeText = 'Student';
            else if (card.type?.includes('Monster') && card.race) subtypeText = card.race;
            else if (card.type?.includes('Artifact')) subtypeText = 'Artifact';
            else if (card.type?.includes('Spell')) subtypeText = 'Spell Card';
            else if (card.type?.includes('Booster')) subtypeText = 'Booster';
            else if (card.type?.includes('Item')) subtypeText = 'Item';
            
            if (subtypeText) {
                // Draw gradient background (matching new CSS) with enhanced opacity for deluxe mode
                const subtypeGradient = ctx.createLinearGradient(3, currentY, 3, currentY + 24);
                if (isDeluxeMode) {
                    subtypeGradient.addColorStop(0, 'rgba(30, 28, 18, 0.3)'); // Much more transparent for deluxe
                    subtypeGradient.addColorStop(1, 'rgba(44, 38, 20, 0.3)');
                } else {
                    subtypeGradient.addColorStop(0, '#1E1C12'); // --parchment-dark
                    subtypeGradient.addColorStop(1, '#2C2614'); // --parchment
                }
                ctx.fillStyle = subtypeGradient;
                ctx.fillRect(3, currentY, 274, 24);
                
                // Draw top border (thicker and gold for deluxe mode)
                ctx.strokeStyle = isDeluxeMode ? '#daac17' : '#97740a'; // Gold for deluxe
                ctx.lineWidth = isDeluxeMode ? 3 : 1;
                ctx.strokeRect(3, currentY, 274, 1);
                
                // Draw bottom border (thicker and gold for deluxe mode)
                ctx.lineWidth = isDeluxeMode ? 4 : 2;
                ctx.strokeRect(3, currentY + 24, 274, 2);
                
                // Add inner borders for deluxe mode
                if (isDeluxeMode) {
                    ctx.strokeStyle = '#97740a'; // Dark gold inner border
                    ctx.lineWidth = 1;
                    ctx.strokeRect(4, currentY + 1, 272, 22);
                }
                
                // Draw subtype text with enhanced styling for deluxe mode
                ctx.fillStyle = '#ebc20e'; // --ink
                ctx.font = 'bold italic 12px serif'; // Larger and bold
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                if (isDeluxeMode) {
                    // Add stronger shadow and glow for deluxe mode
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.9)';
                    ctx.shadowOffsetX = 2;
                    ctx.shadowOffsetY = 2;
                    ctx.shadowBlur = 4;
                    
                    // Add glow effect
                    ctx.strokeStyle = 'rgba(218, 172, 23, 0.8)'; // Gold glow
                    ctx.lineWidth = 2;
                    ctx.strokeText(subtypeText, 140, currentY + 12);
                } else {
                    ctx.shadowColor = 'rgba(0,0,0,0.5)';
                    ctx.shadowOffsetX = 1;
                    ctx.shadowOffsetY = 1;
                    ctx.shadowBlur = 2;
                }
                
                ctx.fillText(subtypeText, 140, currentY + 12);
                ctx.shadowColor = 'transparent'; // Reset shadow
                
                currentY += 26;
            }
            
            // Draw ability section if available (matching .ability-section)
            if (card.ability && card.ability.name) {
                const abilityAreaHeight = card.flavor_text ? 80 : (420 - currentY - 5); // Reduce height if flavor text exists
                
                // Ability background with enhanced opacity for deluxe mode
                ctx.fillStyle = isDeluxeMode ? 'rgba(30, 28, 18, 0.25)' : '#1E1C12'; // Much more transparent for deluxe
                ctx.fillRect(8, currentY, 264, abilityAreaHeight);
                
                // Ability border with enhanced styling for deluxe mode
                ctx.strokeStyle = isDeluxeMode ? '#daac17' : '#97740a'; // Gold border for deluxe
                ctx.lineWidth = isDeluxeMode ? 3 : 1; // Much thicker border for deluxe
                ctx.strokeRect(8, currentY, 264, abilityAreaHeight);
                
                // Add inner border for deluxe mode
                if (isDeluxeMode) {
                    ctx.strokeStyle = '#97740a'; // Dark gold inner border
                    ctx.lineWidth = 1;
                    ctx.strokeRect(9, currentY + 1, 262, abilityAreaHeight - 2);
                }
                
                // Ability name with enhanced styling for deluxe mode
                ctx.fillStyle = '#daac17'; // --gold
                ctx.font = 'bold 12px serif';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                
                if (isDeluxeMode) {
                    // Add text shadow for deluxe mode
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                    ctx.shadowOffsetX = 1;
                    ctx.shadowOffsetY = 1;
                    ctx.shadowBlur = 3;
                }
                
                ctx.fillText(card.ability.name, 15, currentY + 8);
                
                // Ability description with word wrapping and enhanced styling for deluxe mode
                if (card.ability.description) {
                    ctx.fillStyle = '#ebc20e'; // --ink
                    ctx.font = '10px serif';
                    
                    const words = card.ability.description.split(' ');
                    let line = '';
                    let lineY = currentY + 25;
                    const maxWidth = 250;
                    const lineHeight = 12;
                    
                    for (let n = 0; n < words.length; n++) {
                        const testLine = line + words[n] + ' ';
                        const metrics = ctx.measureText(testLine);
                        
                        if (metrics.width > maxWidth && n > 0) {
                            ctx.fillText(line.trim(), 15, lineY);
                            line = words[n] + ' ';
                            lineY += lineHeight;
                            
                            // Stop if we're running out of space
                            if (lineY > currentY + abilityAreaHeight - lineHeight) break;
                        } else {
                            line = testLine;
                        }
                    }
                    
                    // Draw the last line
                    if (line.trim() && lineY <= currentY + abilityAreaHeight - lineHeight) {
                        ctx.fillText(line.trim(), 15, lineY);
                    }
                }
                
                // Reset shadow
                ctx.shadowColor = 'transparent';
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                ctx.shadowBlur = 0;
                
                currentY += abilityAreaHeight + 3; // Move current Y position down
            }
            
            // Draw flavor text section if available (must appear at bottom of card)
            if (card.flavor_text) {
                const flavorAreaHeight = 420 - currentY - 5;
                
                // Flavor text background with enhanced opacity for deluxe mode
                ctx.fillStyle = isDeluxeMode ? 'rgba(30, 28, 18, 0.25)' : '#1E1C12'; // Much more transparent for deluxe
                ctx.fillRect(8, currentY, 264, flavorAreaHeight);
                
                // Flavor text border with enhanced styling for deluxe mode
                ctx.strokeStyle = isDeluxeMode ? '#daac17' : '#97740a'; // Gold border for deluxe
                ctx.lineWidth = isDeluxeMode ? 3 : 1; // Much thicker border for deluxe
                ctx.strokeRect(8, currentY, 264, flavorAreaHeight);
                
                // Add inner border for deluxe mode
                if (isDeluxeMode) {
                    ctx.strokeStyle = '#97740a'; // Dark gold inner border
                    ctx.lineWidth = 1;
                    ctx.strokeRect(9, currentY + 1, 262, flavorAreaHeight - 2);
                }
                
                // Flavor text with quotation marks and centering, enhanced for deluxe mode
                ctx.fillStyle = '#8f770d'; // --ink2 (slightly muted)
                ctx.font = 'italic 9px serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                
                if (isDeluxeMode) {
                    // Add text shadow for deluxe mode
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                    ctx.shadowOffsetX = 1;
                    ctx.shadowOffsetY = 1;
                    ctx.shadowBlur = 2;
                }
                
                // Word wrap the flavor text
                const flavorText = `"${card.flavor_text}"`;
                const words = flavorText.split(' ');
                let line = '';
                let lineY = currentY + 12;
                const maxWidth = 240;
                const lineHeight = 11;
                
                for (let n = 0; n < words.length; n++) {
                    const testLine = line + words[n] + ' ';
                    const metrics = ctx.measureText(testLine);
                    
                    if (metrics.width > maxWidth && n > 0) {
                        ctx.fillText(line.trim(), 140, lineY); // Center text at x=140
                        line = words[n] + ' ';
                        lineY += lineHeight;
                        
                        // Stop if we're running out of space
                        if (lineY > currentY + flavorAreaHeight - lineHeight) break;
                    } else {
                        line = testLine;
                    }
                }
                
                // Draw the last line
                if (line.trim() && lineY <= currentY + flavorAreaHeight - lineHeight) {
                    ctx.fillText(line.trim(), 140, lineY);
                }
                
                // Reset shadow
                ctx.shadowColor = 'transparent';
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                ctx.shadowBlur = 0;
            }
            
            return canvas;
        }
        
        function filterCards() {
            const searchTerm = searchInput.value.toLowerCase();
            const typeValue = typeFilter.value;
            const tierValue = tierFilter.value;
            const energyValue = energyFilter.value;
            
            filteredCards = cards.filter(card => {
                const matchesSearch = !searchTerm || 
                    card.name.toLowerCase().includes(searchTerm) ||
                    (card.type && card.type.toLowerCase().includes(searchTerm)) ||
                    (card.race && card.race.toLowerCase().includes(searchTerm)) ||
                    (card.tier && card.tier.toLowerCase().includes(searchTerm)) ||
                    (card.ability && card.ability.name && card.ability.name.toLowerCase().includes(searchTerm)) ||
                    (card.ability && card.ability.description && card.ability.description.toLowerCase().includes(searchTerm));
                
                const matchesType = !typeValue || card.type === typeValue;
                const matchesTier = !tierValue || card.tier === tierValue;
                const matchesEnergy = !energyValue || (card.cost && card.cost.toLowerCase().includes(energyValue.toLowerCase()));
                
                return matchesSearch && matchesType && matchesTier && matchesEnergy;
            });
            
            renderCards();
        }
        
        // Card operations
        // Modal art cycling
        let modalArtIndex = 0;
        let modalArtVariants = [];

        function cycleModalArt(direction = 1) {
            if (modalArtVariants.length <= 1) return;
            
            modalArtIndex = (modalArtIndex + direction + modalArtVariants.length) % modalArtVariants.length;
            
            const modalImage = document.querySelector('.modal-image');
            const artIndicator = document.querySelector('.modal-art-indicator');
            
            if (modalImage) {
                modalImage.src = modalArtVariants[modalArtIndex];
            }
            if (artIndicator) {
                artIndicator.textContent = `${modalArtIndex + 1}/${modalArtVariants.length}`;
            }
            
            // Sync with the grid card if available
            if (currentModalCard && currentModalCardIndex !== undefined) {
                const uniqueId = `${currentModalCard.id}_${currentModalCardIndex}`;
                currentArtIndex[uniqueId] = modalArtIndex;
                
                // Update the grid card image and indicator
                const cardElement = document.querySelector(`[data-card-id="${currentModalCard.id}"][data-card-index="${currentModalCardIndex}"]`);
                if (cardElement) {
                    const imgElement = cardElement.querySelector('.card-image');
                    const indicator = cardElement.querySelector('.art-indicator');
                    
                    if (imgElement) {
                        imgElement.src = modalArtVariants[modalArtIndex];
                    }
                    if (indicator) {
                        indicator.textContent = `${modalArtIndex + 1}/${modalArtVariants.length}`;
                    }
                }
            }
        }

        function showCardDetails(card, cardIndex = 0) {
            if (!card) return;
            
            // Store the current card and its index for printing
            currentModalCard = card;
            currentModalCardIndex = cardIndex;
            
            // Get art variants for modal - use the current art variant from the grid
            const variants = getArtVariants(card);
            modalArtVariants = variants;
            
            // Use the current art index from the grid if available
            const uniqueId = `${card.id}_${cardIndex}`;
            const currentGridIndex = currentArtIndex[uniqueId] || 0;
            modalArtIndex = currentGridIndex;
            
            const imageUrl = variants[modalArtIndex] || card.image_url || card.image_placeholder;
            
            document.getElementById('modalCardTitle').textContent = card.name;
            document.getElementById('modalCardContent').innerHTML = `
                <div class="modal-image-container" style="position: relative; text-align: center; margin-bottom: 20px;">
                    ${variants.length > 1 ? `
                        <div class="modal-art-controls" style="position: absolute; top: 10px; right: 10px; display: flex; align-items: center; gap: 8px; background: rgba(0, 0, 0, 0.8); padding: 5px 10px; border-radius: 5px; z-index: 10;">
                            <button class="art-cycle-btn prev" onclick="cycleModalArt(-1)" title="Previous Art">‹</button>
                            <span class="modal-art-indicator" style="color: var(--ink); font-size: 0.8rem; font-weight: bold; min-width: 40px;">1/${variants.length}</span>
                            <button class="art-cycle-btn next" onclick="cycleModalArt(1)" title="Next Art">›</button>
                        </div>
                    ` : ''}
                    ${imageUrl ? `<img src="${imageUrl}" alt="${card.name}" class="modal-image" onerror="this.style.display='none';" style="max-width: 100%; max-height: 400px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.3);">` : ''}
                </div>
                
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px;">
                    <div>
                        <strong style="color: var(--gold);">Type:</strong><br>
                        <span style="color: var(--ink);">${card.type || 'Unknown'}</span>
                    </div>
                    <div>
                        <strong style="color: var(--gold);">Cost:</strong><br>
                        <span class="${getEnergyClass(card.cost)}" style="padding: 4px 8px; border-radius: 4px; font-weight: bold;">${card.cost || 'Free'}</span>
                    </div>
                    ${card.race ? `
                        <div>
                            <strong style="color: var(--gold);">Race:</strong><br>
                            <span style="color: var(--ink);">${card.race}</span>
                        </div>
                    ` : ''}
                    ${card.tier ? `
                       
                        <div>
                            <strong style="color: var(--gold);">Tier:</strong><br>
                            <span style="color: var(--ink);">${card.tier}</span>
                        </div>
                    ` : ''}
                    ${card.hp !== undefined && card.hp !== null ? `
                        <div>
                            <strong style="color: var(--gold);">HP:</strong><br>
                            <span class="stat-badge hp-badge">${card.hp}</span>
                        </div>
                    ` : ''}
                    ${card.atk !== undefined && card.atk !== null ? `
                        <div>
                            <strong style="color: var(--gold);">ATK:</strong><br>
                            <span class="stat-badge atk-badge">${card.atk}</span>
                        </div>
                    ` : ''}
                </div>
                
                ${card.ability && card.ability.name ? `
                    <div class="ability-section">
                        <div class="ability-name" style="font-size: 1.2rem; margin-bottom: 10px;">${card.ability.name}</div>
                        <div class="ability-description" style="font-size: 1rem; line-height: 1.6;">${card.ability.description || ''}</div>
                    </div>
                ` : ''}
                
                ${card.flavor_text ? `
                    <div class="flavor-text-section" style="background-color: var(--parchment-dark); border: 1px solid var(--gold-dark); border-radius: 6px; padding: 15px; margin-top: 12px; text-align: center;">
                        <div class="flavor-text" style="font-style: italic; color: var(--ink2); font-size: 1rem; line-height: 1.4;">"${card.flavor_text}"</div>
                    </div>
                ` : ''}
            `;
            
            cardModal.classList.add('active');
        }
        
        // Storage functions
        function saveToStorage() {
            localStorage.setItem('diaperSchoolTCG', JSON.stringify(cards));
        }
        
        function loadFromStorage() {
            const stored = localStorage.getItem('diaperSchoolTCG');
            if (stored) {
                try {
                    const loadedCards = JSON.parse(stored);
                    // Merge with initial data, keeping user additions
                    const initialIds = initialCardData.map(c => c.id);
                    const userCards = loadedCards.filter(c => !initialIds.includes(c.id));
                    cards = [...initialCardData, ...userCards];
                    filteredCards = [...cards];
                } catch (e) {
                    console.error('Failed to load saved cards:', e);
                }
            }
        }
        
        function exportData() {
            const dataStr = JSON.stringify(cards, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'diaper-school-tcg-cards.json';
            link.click();
            URL.revokeObjectURL(url);
        }
        
        function importData() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = function(event) {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        try {
                            const importedCards = JSON.parse(e.target.result);
                            if (Array.isArray(importedCards)) {
                                showAppConfirm(`Add ${importedCards.length} cards to your collection?`).then(ok => { if(!ok) return;
                                // Check for duplicate IDs and filter them out
                                const existingIds = new Set(cards.map(c => c.id));
                                const newCards = importedCards.filter(card => !existingIds.has(card.id));
                                const duplicates = importedCards.length - newCards.length;
                                
                                // Add new cards to collection
                                cards = [...cards, ...newCards];
                                filteredCards = [...cards];
                                filterCards();
                                updateStats();
                                saveToStorage();
                                
                                if (duplicates > 0) { showAppAlert(`Added ${newCards.length} new cards! Skipped ${duplicates} duplicate(s).`); }
                                else { showAppAlert(`Added ${newCards.length} new cards to your collection!`); }
                                });
                            }
                        } catch (error) {
                            showAppAlert('Error reading file: ' + error.message);
                        }
                    };
                    reader.readAsText(file);
                }
            };
            input.click();
        }
        
        function importBoosterPack() {
            // Present a small chooser modal so user can pick Folder mode OR Zip/File mode
            const choiceModal = document.createElement('div');
            choiceModal.className = 'modal active';
            choiceModal.innerHTML = `
              <div class="modal-content" style="max-width:420px;">
                <div class="modal-header"><h3>📦 Import Booster Pack</h3></div>
                <div class="modal-body" style="display:flex;flex-direction:column;gap:14px;">
                  <p style="margin:0;">Choose how you'd like to import your booster content:</p>
                  <button id="boosterFolderBtn" class="primary" style="padding:10px 14px;">📁 Folder (JSON + images)</button>
                  <button id="boosterZipBtn" style="padding:10px 14px;">🗜️ Zip Archive (.zip)</button>
                  <button id="boosterFilesBtn" style="padding:6px 10px;font-size:.8em;">🧩 Individual Files (.json / images)</button>
                  <button id="boosterCancelBtn" style="padding:6px 10px;font-size:.8em;">Cancel</button>
                </div>
              </div>`;
            document.body.appendChild(choiceModal);

            const closeChoice = ()=>{ if(choiceModal.parentNode) document.body.removeChild(choiceModal); };

            function launchFolderMode(){
                closeChoice();
                const input = document.createElement('input');
                input.type = 'file';
                input.webkitdirectory = true; // folder selection (allows all nested files)
                input.multiple = true;
                input.accept = '.json,image/*'; // zip not relevant in folder mode
                input.onchange = (e)=> handleBoosterFiles(e, true);
                input.click();
            }
            function launchZipMode(){
                closeChoice();
                const input = document.createElement('input');
                input.type = 'file';
                input.multiple = false; // single zip expected
                input.accept = '.zip';
                input.onchange = (e)=> handleBoosterFiles(e, false);
                input.click();
            }
            function launchIndividualFiles(){
                closeChoice();
                const input = document.createElement('input');
                input.type = 'file';
                input.multiple = true; // allow selecting json + images together (same directory only)
                input.accept = '.zip,.json,image/*';
                input.onchange = (e)=> handleBoosterFiles(e, false);
                input.click();
            }

            choiceModal.querySelector('#boosterFolderBtn').addEventListener('click', launchFolderMode);
            choiceModal.querySelector('#boosterZipBtn').addEventListener('click', launchZipMode);
            choiceModal.querySelector('#boosterFilesBtn').addEventListener('click', launchIndividualFiles);
            choiceModal.querySelector('#boosterCancelBtn').addEventListener('click', closeChoice);

            async function handleBoosterFiles(event, isFolderMode){
                const files = Array.from(event.target.files || []);
                if(!files.length) return;
                // Continue into main shared logic below (moved from original onchange)
                await processBoosterSelection(files);
            }

            async function processBoosterSelection(files){
                // ORIGINAL BODY (slightly refactored) STARTS HERE
                // Detect zip-only selection (one .zip file, no directory entries)
                const zipFile = (files.length === 1 && /\.zip$/i.test(files[0].name)) ? files[0] : null;

                // Modal UI
                const progressModal = document.createElement('div');
                progressModal.className = 'modal active';
                progressModal.innerHTML = `
                    <div class="modal-content" style="max-width: 520px;">
                        <div class="modal-header"><h3>📦 Importing Booster Pack</h3></div>
                        <div class="modal-body" style="text-align:center;">
                            <div id="folderImportProgress">Preparing...</div>
                            <div style="margin:20px 0;">
                                <div class="progress-bar" style="width:100%;height:20px;background:var(--parchment-dark);border:1px solid var(--gold);border-radius:10px;overflow:hidden;">
                                    <div id="folderImportBar" style="width:0%;height:100%;background:var(--gold);transition:width .25s ease;"></div>
                                </div>
                            </div>
                            <div id="folderImportDetails" style="font-size:.85em;color:var(--ink2);"></div>
                        </div>
                    </div>`;
                document.body.appendChild(progressModal);

                // Shared accumulators
                let allNewCards = [];
                let imageMap = new Map();
                let processed = 0;
                let totalPlanned = 0;
                let updatedImages = 0;
                let variantsUpdated = 0;

                const setDetail = (msg) => {
                    const el = document.getElementById('folderImportDetails');
                    if (el) el.textContent = msg;
                };
                const setStage = (msg) => {
                    const el = document.getElementById('folderImportProgress');
                    if (el) el.textContent = msg;
                };
                const bump = () => {
                    processed++; updateProgressBar(processed, totalPlanned);
                };

                try {
                    if (zipFile) {
                        if (!window.fflate || !fflate.unzipSync) throw new Error('fflate library missing (replace placeholder with real fflate.min.js)');
                        setStage('Reading zip...');
                        const buf = new Uint8Array(await zipFile.arrayBuffer());
                        setStage('Unpacking zip...');
                        let entries;
                        try {
                            entries = fflate.unzipSync(buf); // { filename: Uint8Array }
                        } catch (e) {
                            throw new Error('Failed to unzip archive: ' + e.message);
                        }
                        const names = Object.keys(entries);
                        const jsonNames = names.filter(n => n.toLowerCase().endsWith('.json'));
                        const imageNames = names.filter(n => /\.(webp|png|jpe?g|gif)$/i.test(n));
                        totalPlanned = jsonNames.length + imageNames.length || 1;
                        setDetail(`Zip contains ${jsonNames.length} JSON and ${imageNames.length} image file(s)`);

                        // Parse JSON entries
                        for (const jn of jsonNames) {
                            setStage('Parsing ' + jn + '...');
                            try {
                                const text = new TextDecoder().decode(entries[jn]);
                                const data = JSON.parse(text);
                                if (Array.isArray(data)) allNewCards.push(...data); else if (data && typeof data === 'object') allNewCards.push(data);
                            } catch (e) {
                                console.warn('JSON parse failed for', jn, e);
                            }
                            bump();
                        }
                        setStage('Processing images...');
                        // Convert images to data URLs
                        for (const imgName of imageNames) {
                            const lower = imgName.split('/').pop().toLowerCase();
                            const bytes = entries[imgName];
                            // Determine MIME
                            const ext = lower.split('.').pop();
                            const mime = ext === 'png' ? 'image/png' : ext === 'gif' ? 'image/gif' : ext === 'jpg' || ext === 'jpeg' ? 'image/jpeg' : 'image/webp';
                            const blob = new Blob([bytes], { type: mime });
                            const dataUrl = await new Promise(res => { const r = new FileReader(); r.onload = e => res(e.target.result); r.readAsDataURL(blob); });
                            imageMap.set(lower, dataUrl);
                            imageMap.set(imgName, dataUrl);
                            bump();
                        }
                    } else {
                        // Folder or individual multi-file mode
                        const jsonFiles = files.filter(f => f.name.toLowerCase().endsWith('.json'));
                        const imageFiles = files.filter(f => /\.(webp|png|jpg|jpeg|gif)$/i.test(f.name));
                        totalPlanned = jsonFiles.length + imageFiles.length || 1;
                        setDetail(`Found ${jsonFiles.length} JSON file(s) and ${imageFiles.length} image(s)`);
                        if (!jsonFiles.length) throw new Error('No JSON files found in selection.');
                        for (const jf of jsonFiles) {
                            setStage('Reading ' + jf.name + '...');
                            try {
                                const txt = await readFileAsText(jf);
                                const data = JSON.parse(txt);
                                if (Array.isArray(data)) allNewCards.push(...data); else if (data && typeof data === 'object') allNewCards.push(data);
                            } catch (e) { console.warn('Parse failed for', jf.name, e); }
                            bump();
                        }
                        setStage('Processing images...');
                        for (const img of imageFiles) {
                            setStage('Image: ' + img.name);
                            const url = await readFileAsDataURL(img);
                            const lower = img.name.toLowerCase();
                            imageMap.set(lower, url); imageMap.set(img.name, url);
                            bump();
                        }
                    }

                    setStage(`Processing ${allNewCards.length} cards...`);

                    // Variant & image replacement (reuse existing logic compressed)
                    allNewCards.forEach(card => {
                        if (!card || !card.image_url) return;
                        const originalPath = card.image_url;
                        const filename = originalPath.split('/').pop().toLowerCase();
                        let baseNameForVariants = '';
                        let mainImageFound = false;
                        if (imageMap.has(filename)) {
                            card.image_url = imageMap.get(filename); mainImageFound = true; updatedImages++; baseNameForVariants = filename.replace(/\.[^.]+$/, '');
                        } else {
                            const nameWithoutExt = filename.replace(/\.[^.]+$/, '');
                            const match = Array.from(imageMap.keys()).find(k => k.includes(nameWithoutExt) || nameWithoutExt.includes(k.replace(/\.[^.]+$/, '')));
                            if (match) { card.image_url = imageMap.get(match); mainImageFound = true; updatedImages++; baseNameForVariants = match.replace(/\.[^.]+$/, ''); }
                        }
                        const variants = [];
                        if (baseNameForVariants) {
                            const ext = filename.match(/\.([^.]+)$/)?.[1] || 'webp';
                            for (let i=1;i<=30;i++) { const v1 = `${baseNameForVariants} (${i}).${ext}`; const v2 = `${baseNameForVariants}(${i}).${ext}`; if (imageMap.has(v1)) { variants.push(imageMap.get(v1)); variantsUpdated++; } else if (imageMap.has(v2)) { variants.push(imageMap.get(v2)); variantsUpdated++; } }
                        }
                        const cardNameLower = card.name?.toLowerCase().replace(/[^a-z0-9]/g,'');
                        if (cardNameLower) {
                            for (const key of imageMap.keys()) {
                                if (/\(\d+\)/.test(key)) {
                                    const cleaned = key.toLowerCase().replace(/[^a-z0-9]/g,'');
                                    if (cleaned.includes(cardNameLower)) {
                                        const url = imageMap.get(key);
                                        if (url && url !== card.image_url && !variants.includes(url)) { variants.push(url); variantsUpdated++; }
                                    }
                                }
                            }
                        }
                        if (!mainImageFound) {
                            const cardNameClean = cardNameLower;
                            for (const key of imageMap.keys()) {
                                const cleaned = key.toLowerCase().replace(/[^a-z0-9]/g,'');
                                if (cardNameClean && cleaned.includes(cardNameClean)) { card.image_url = imageMap.get(key); updatedImages++; break; }
                            }
                        }
                        if (variants.length) { artVariantsCache.set(card.id, [card.image_url, ...variants]); }
                    });

                    // Deduplicate by id
                    const existingIds = new Set(cards.map(c => c.id));
                    const newCards = allNewCards.filter(c => c && !existingIds.has(c.id));
                    const duplicates = allNewCards.length - newCards.length;
                    cards = [...cards, ...newCards];
                    filteredCards = [...cards];
                    filterCards(); updateStats(); saveToStorage();
                    document.body.removeChild(progressModal);
                    const unmatchedImages = Math.max(0, imageMap.size - (updatedImages + variantsUpdated));
                    const msg = `🎉 Booster Pack Imported Successfully!\n\n📋 ${newCards.length} new cards added\n🖼️ ${updatedImages} main images updated\n🎨 ${variantsUpdated} art variants found${duplicates>0?`\n⚠️ ${duplicates} duplicate(s) skipped`:''}${unmatchedImages>0?`\n📝 Note: some images (${unmatchedImages}) could not be matched.`:''}`;
                    showAppAlert(msg);
                } catch (err) {
                    document.body.removeChild(progressModal);
                    showAppAlert('Error importing booster pack: ' + err.message);
                    console.error('Booster pack import error:', err);
                }
            }
            // END refactored logic
        }
        
        // Helper functions for file reading
        function readFileAsText(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = e => resolve(e.target.result);
                reader.onerror = e => reject(e);
                reader.readAsText(file);
            });
        }
        
        function readFileAsDataURL(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = e => resolve(e.target.result);
                reader.onerror = e => reject(e);
                reader.readAsDataURL(file);
            });
        }
        
        function updateProgressBar(current, total) {
            const percentage = (current / total) * 100;
            const progressBar = document.getElementById('folderImportBar');
            if (progressBar) {
                progressBar.style.width = percentage + '%';
            }
        }
        
        // Event listeners
        searchInput.addEventListener('input', filterCards);
        typeFilter.addEventListener('change', filterCards);
        tierFilter.addEventListener('change', filterCards);
        energyFilter.addEventListener('change', filterCards);
        
        document.getElementById('exportBtn').addEventListener('click', exportData);
        document.getElementById('importBtn').addEventListener('click', importData);
        document.getElementById('importFolderBtn').addEventListener('click', importBoosterPack);
        
        // Deck Builder Event Listeners
        toggleDeckBtn.addEventListener('click', toggleDeckView);
        clearDeckBtn.addEventListener('click', clearDeck);
        saveDeckBtn.addEventListener('click', saveDeck);
        loadDeckBtn.addEventListener('click', loadDeck);
    document.getElementById('loadStarterDeck1Btn').addEventListener('click', loadStarterDeck1);
    document.getElementById('loadDarklingDeckBtn').addEventListener('click', loadDarklingDeck);
    document.getElementById('loadElementalDeckBtn').addEventListener('click', loadElementalFluxDeck);
        document.getElementById('playAllCardsBtn').addEventListener('click', playAllCardsToBoard);
        exportPngBtn.addEventListener('click', exportDeckAsPNG);
        
        printCardBtn.addEventListener('click', printSingleCard);
        
        document.getElementById('closeModalBtn').addEventListener('click', () => {
            cardModal.classList.remove('active');
            currentModalCard = null; // Clear the current card when modal closes
        });
        
        // Close modals when clicking outside
        cardModal.addEventListener('click', (e) => {
            if (e.target === cardModal) {
                cardModal.classList.remove('active');
                currentModalCard = null; // Clear the current card when modal closes
            }
        });
        
        // Initialize
        async function init() {
            // Initialize processing indicator
            const processingToggle = document.getElementById('processingToggle');
            const processingIndicator = document.getElementById('processingIndicator');
            
            if (processingToggle) {
                processingToggle.addEventListener('click', toggleProcessingMinimized);
            }
            
            // Set initial state
            if (processingMinimized) {
                processingIndicator.classList.add('minimized');
                processingToggle.textContent = '+';
                processingToggle.title = 'Show processing details';
            }
            
            // Add right-click option to disable processing indicator
            processingIndicator.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                showAppConfirm('Hide processing indicator? You can re-enable it from browser console with: toggleProcessingIndicator()').then(ok => { if (ok) toggleProcessingIndicator(); });
            });
            
            showProcessingIndicator('init', 'Loading cards...', 0);
            
            // Initialize cards from external data
            if (typeof initialCardData !== 'undefined') {
                cards = [...initialCardData];
                filteredCards = [...cards];
                updateProcessingIndicator('init', 'Cards loaded, processing...', 25);
                
                // Preload art variants for all cards and wait for completion
                updateProcessingIndicator('init', 'Loading art variants...', 50);
                await preloadAllArtVariants();
                
                updateProcessingIndicator('init', 'Finalizing...', 90);
                loadFromStorage();
                filterCards();
                updateStats();
                updateDeckStats();
                // Robust zone restoration: load saved zones if present; if absent/empty seed defaults
                (function ensureZones(){
                    const savedBoardRaw = localStorage.getItem(BOARD_STORAGE_KEY);
                    if (savedBoardRaw) {
                        try {
                            const state = JSON.parse(savedBoardRaw);
                            if (state && Array.isArray(state.zones) && state.zones.length > 0) {
                                placeableZones = state.zones;
                                placeableZones.forEach(z => renderPlaceableZone(z));
                                const maxIdNum = placeableZones.reduce((m,z)=>{ const n=parseInt((z.id||'').split('_')[1])||0; return n>m?n:m; },0);
                                zoneIdCounter = maxIdNum + 1;
                                return; // done
                            }
                        } catch(e) { console.warn('Failed parsing saved board zones, seeding defaults', e); }
                    }
                    // If we reach here, no usable zones were loaded
                    if (placeableZones.length === 0) {
                        placeableZones = JSON.parse(JSON.stringify(DEFAULT_ZONES));
                        placeableZones.forEach(z => renderPlaceableZone(z));
                        const maxIdNum = placeableZones.reduce((m,z)=>{ const n=parseInt((z.id||'').split('_')[1])||0; return n>m?n:m; },0);
                        zoneIdCounter = maxIdNum + 1;
                    }
                })();
                updateAddButtons();
                updateProcessingIndicator('init', 'Ready!', 100);
                setTimeout(() => {
                    loadingSpinner.style.display = 'none';
                    hideProcessingIndicator('init');
                }, 1000);
            } else {
                // Retry if cards haven't loaded yet
                hideProcessingIndicator('init');
                setTimeout(init, 100);
            }
        }
        
        // Preload art variants for all cards
        async function preloadAllArtVariants() {
            showProcessingIndicator('artVariants', 'Preloading art variants...', 0);
            const total = cards.length;
            let completed = 0;
            
            const promises = cards.map(async (card, index) => {
                await preloadArtVariants(card);
                completed++;
                const progress = Math.round((completed / total) * 100);
                updateProcessingIndicator('artVariants', `Preloading art variants... (${completed}/${total})`, progress);
            });
            
            await Promise.all(promises);
            console.log('Art variants preloaded for', artVariantsCache.size, 'cards');
            
            setTimeout(() => hideProcessingIndicator('artVariants'), 1000);
            
            // Re-render cards to show art cycle buttons where appropriate
            renderCards();
        }

        // PWA Service Worker Registration
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js')
                    .then((registration) => {
                        console.log('SW registered: ', registration);
                    })
                    .catch((registrationError) => {
                        console.log('SW registration failed: ', registrationError);
                    });
            });
        }

        // PWA Install Prompt
        let deferredPrompt;
        window.addEventListener('beforeinstallprompt', (e) => {
            console.log('PWA install prompt available');
            e.preventDefault();
            deferredPrompt = e;
            
            // Show install button (you can add this to your UI)
            showInstallButton();
        });

        function showInstallButton() {
            // Create install button if it doesn't exist
            let installBtn = document.getElementById('installBtn');
            if (!installBtn) {
                installBtn = document.createElement('button');
                installBtn.id = 'installBtn';
                installBtn.className = 'btn';
                installBtn.innerHTML = '📱 Install App';
                installBtn.style.position = 'fixed';
                installBtn.style.top = '20px';
                installBtn.style.right = '20px';
                installBtn.style.zIndex = '1000';
                installBtn.style.backgroundColor = 'var(--gold)';
                installBtn.style.color = 'var(--parchment)';
                
                installBtn.addEventListener('click', installPWA);
                document.body.appendChild(installBtn);
            }
            installBtn.style.display = 'block';
        }

        function installPWA() {
            if (deferredPrompt) {
                deferredPrompt.prompt();
                deferredPrompt.userChoice.then((choiceResult) => {
                    if (choiceResult.outcome === 'accepted') {
                        console.log('User accepted the install prompt');
                    } else {
                        console.log('User dismissed the install prompt');
                    }
                    deferredPrompt = null;
                    document.getElementById('installBtn').style.display = 'none';
                });
            }
        }

        // Hide install button when app is already installed
        window.addEventListener('appinstalled', (evt) => {
            console.log('App was installed.');
            const installBtn = document.getElementById('installBtn');
            if (installBtn) {
                installBtn.style.display = 'none';
            }
        });
    // Keep grid overlay consistent on resize
    window.addEventListener('resize', ()=>{ if(gridVisible) updateGridOverlay(); });
    
    // Toolbar toggle logic
    (function initToolbarToggle(){
        const toggleBtn = document.getElementById('toolbarToggleBtn');
        const toolbar = document.getElementById('boardToolbar');
    const lifeCounterEl = document.getElementById('lifeCounter');
        if(!toggleBtn || !toolbar) return;
    function applyLayout(){ /* life counter now fixed on right; no dynamic shift needed */ }
        function updateLabel(){
            if(toolbar.classList.contains('hidden')){
                toggleBtn.textContent = 'Tools ▸';
            } else {
                toggleBtn.textContent = 'Tools ▾';
            }
            applyLayout();
        }
        toggleBtn.addEventListener('click', ()=>{ toolbar.classList.toggle('hidden'); updateLabel(); });
        updateLabel(); // initial
    })();
        
        // Make processing indicator functions available globally for console access
        window.toggleProcessingIndicator = toggleProcessingIndicator;
        window.showProcessingIndicator = showProcessingIndicator;
        window.hideProcessingIndicator = hideProcessingIndicator;
        
        // init() is called by the script.onload event
    </script>
</body>
</html>
